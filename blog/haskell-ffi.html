<!DOCTYPE html>
<html>
<head>
<title>Haskell 2010 の FFI 周りについて</title>
<!-- 2018-01-22 Mon 16:26 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/prelude.css" />
<link rel="stylesheet" type="text/css" href="/css/highlight.css" />
</head>
<body>
<div id="content">
<h1 class="title">Haskell 2010 の FFI 周りについて</h1>
<div class="location">
<p>
https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>haskell-ffi.html</strong>
</p>

</div>

<div class="created_at">
<p>
created at <time datetime="2018-01-22">2018-01-22</time>
</p>

</div>

<div class="updated_at">
<p>
updated at <time datetime="2018-01-22">2018-01-22</time>
</p>

</div>

<p>
Haskell 2010 で定義されている FFI について記しておく．
まず， 簡単に FFI の例を見てみよう．
</p>

<div class="highlight"><pre><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">safe</span> <span class="s">&quot;static math.h sin&quot;</span> <span class="n">csin</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">safe</span> <span class="s">&quot;static math.h cos&quot;</span> <span class="n">ccos</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">safe</span> <span class="s">&quot;static math.h tan&quot;</span> <span class="n">ctan</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
</pre></div>

<p>
順に見ていく．
</p>

<ul class="org-ul">
<li><code>foreign import</code> は外部の関数を呼びだすためのキーワードである．
</li>
<li><code>ccall</code> は呼びだし規約で，
ほかにも <code>stdcall</code>, <code>cplusplus</code>, <code>jvm</code>, <code>dotnet</code>,
あるいは処理系依存の呼びだし規約が指定できる．
<code>ccall</code> の実装は必須だが，
そのほかのものは optional である．
処理系はこのほかの呼びだし規約を実装してもよい．
たとえば GHCJS は <code>javascript</code> を実装している．
</li>
<li><code>safe</code> はシステムが外部関数を呼びだすときのふるまいを指定し，
このほかにも <code>unsafe</code> が指定できる．
<code>safe</code> は非効率的だが安全に呼びだされることが保証される．
<code>unsafe</code> は危険だがオーバーヘッドが少ないものを意図しているものの，
規格上のふるまいは未定義である． よく勘違いされるが，
<code>IO</code> や GHC の <code>-XSafe</code> 拡張とは関係がない
(<code>-XSafe</code> 拡張は終域に <code>IO</code> が含まれない FFI をコンパイルエラーにする
言語拡張である． したがって， 上記の <code>sin</code> や <code>cos</code> のような関数は弾かれる．
<code>-XTrustworthy</code> はそのような関数をコンパイルエラーにはせずに，
プログラマが安全な関数のみを使っていることを信頼する言語拡張である)．
</li>
<li><code>static</code> は静的なアドレスであることを意味し， 省略可能である．
<code>math.h</code> は C のヘッダファイルを指定するのだが， 省略可能である．
<code>sin</code> などは C の関数名 (より正確にはリンクする関数名) であり，
<code>&amp;sin</code> などとすることで <code>Ptr</code> 型で関数ポインタを得ることができる．
ほかにも <code>dynamic</code>, <code>wrapper</code> などが指定できる． こちらは省略できない．
なお， まぎらわしいが静的/動的リンクとは関係がない．
</li>
<li><code>csin</code> や <code>Double -&gt; Double</code> などは Haskell の関数名と型である．
FFI で指定できる型は C の型との共通部分にかぎられる．
くわしくは規格を参照されたし．
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Foreign</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>Foreign</code> モジュールは FFI に関するいろいろなユーティリティ関数などを提供する．
<code>Data.Bits</code>, <code>Data.Int</code>, <code>Data.Word</code>, <code>Foreign.Ptr</code>,
<code>Foreign.ForeignPtr</code>, <code>Foreign.StablePtr</code>, <code>Foreign.Storable</code>,
<code>Foreign.Marshal</code> などをリエクスポートしている．
<code>Data.Bits</code> モジュールはビット演算に関する操作を提供している．
<code>Data.Int</code> は符号付つき整数に関する関数など，
<code>Data.Word</code> は符号なし整数に関する関数などである．
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Foreign.Ptr</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>Foreign.Ptr</code> モジュールはポインタを表す型を提供する．
ポインタに関する操作などは，
主に <code>Foreign.Marshal</code> モジュールにある．
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Foreign.Marshal</h2>
<div class="outline-text-2" id="text-3">
<p>
<code>Foreign.Marshal</code> モジュールはポインタに関する操作などを提供する．
<code>Foreign.Marshal.Alloc</code>, <code>Foreign.Marshal.Array</code>,
<code>Foreign.Marshal.Error</code>, <code>Foreign.Marshal.Utils</code> などをリエクスポートしている．
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Foreign.Marshal.Alloc</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>Foreign.Marshal.Alloc</code> モジュールはメモリ確保などの関数を提供する．
</p>

<p>
<code>mallocBytes :: Int -&gt; O (Ptr a)</code> は，
バイト単位でメモリを確保するための関数である．
</p>

<p>
<code>malloc :: Storable a =&gt; IO (Ptr a)</code> は <code>mallocBytes (sizeOf undefined)</code> と等しい
(<code>sizeOf</code> は <code>Foreign.Storable.Storable</code> 型クラスのメソッドである)．
これは遅延評価前提の関数なので， <code>-XStrict</code> 拡張 や <code>-XStrictData</code> 拡張と相性が悪い．
</p>

<p>
<code>allocaBytes :: Int -&gt; (Ptr a -&gt; IO b) -&gt; IO b</code> 関数は
<code>mallocBytes</code> 関数と似ているが， ヒープではなくスタックに確保する．
若干黒魔術めいている．
</p>

<p>
<code>alloca :: Storable a =&gt; (Ptr a -&gt; IO b) -&gt; IO b</code> 関数は
<code>allocaBytes (sizeOf undefined)</code> と等しい．
やはり遅延評価前提なので正格評価と相性が悪い．
</p>

<p>
ほかにも <code>realloc</code>, <code>reallocBytes</code>, <code>free</code> などがあるので調べてほしい．
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Foreign.Marshal.Array</h2>
<div class="outline-text-2" id="text-5">
<p>
<code>Foreign.Marshal.Alloc</code> と似ているモジュールで， メモリ確保などを提供する．
違いは配列を確保するところである．
たとえば <code>mallocArray :: Storable a =&gt; Int -&gt; IO (Ptr a)</code> で
<code>sizeOf undefined * n</code> のサイズの配列を確保できる．
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Foreign.Storable</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>Foreign.Storable</code> 関数はデータのシリアライズ，
デシリアライズのための型クラスを提供する．
<code>malloc</code> 関数などで頻繁に現れるので理解しておく必要がある．
たとえば， <code>data Point = Point Int Int</code>
という型を <code>Storable</code> のインスタンスにしたいとしよう．
すると， 次のようになる．
</p>

<div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Foiregn</span> <span class="c1">-- Foreign.Storable はリエクスポートされている</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="kt">Int</span>

<span class="kr">instance</span> <span class="kt">Foreign</span><span class="o">.</span><span class="kt">Storable</span> <span class="kt">Point</span> <span class="kr">where</span>
  <span class="c1">-- 引数は undefined なので使ってはいけない</span>
  <span class="n">sizeOf</span> <span class="kr">_</span> <span class="ow">=</span> <span class="mi">8</span>
  <span class="n">alignment</span> <span class="kr">_</span> <span class="ow">=</span> <span class="mi">4</span>

  <span class="n">peek</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kt">Foreign</span><span class="o">.</span><span class="n">peek</span> <span class="p">(</span><span class="kt">Foreign</span><span class="o">.</span><span class="n">castPtr</span> <span class="n">p</span> <span class="ow">::</span> <span class="kt">Foreign</span><span class="o">.</span><span class="kt">Ptr</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="n">y</span> <span class="ow">&lt;-</span> <span class="kt">Foreign</span><span class="o">.</span><span class="n">peek</span> <span class="p">(</span><span class="kt">Foreign</span><span class="o">.</span><span class="n">castPtr</span> <span class="p">(</span><span class="kt">Foreign</span><span class="o">.</span><span class="n">plusPtr</span> <span class="n">p</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Foreign</span><span class="o">.</span><span class="kt">Ptr</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="n">return</span> <span class="o">$</span> <span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span>

  <span class="n">poke</span> <span class="n">p</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kt">Foreign</span><span class="o">.</span><span class="n">poke</span> <span class="p">(</span><span class="kt">Foreign</span><span class="o">.</span><span class="n">castPtr</span> <span class="n">p</span><span class="p">)</span> <span class="n">x</span>
    <span class="kt">Foreign</span><span class="o">.</span><span class="n">poke</span> <span class="p">(</span><span class="kt">Foreign</span><span class="o">.</span><span class="n">castPtr</span> <span class="p">(</span><span class="kt">Foreign</span><span class="o">.</span><span class="n">plusPtr</span> <span class="n">p</span> <span class="mi">4</span><span class="p">))</span> <span class="n">y</span>
</pre></div>

<p>
<code>poke</code> 関数は Haskell のデータ型を C の型，
すなわちバイト列へシリアライズし， ポインタへ格納する．
<code>peek</code> 関数でデシリアライズしてデータをとりだす，
という感じである．
</p>

<p>
注意すべきこととしては， <code>sizeOf</code> と <code>alignment</code> の引数を使ってはいけないということ．
ほとんどの場合， 引数として <code>undefined</code> が渡される．
どういう経緯でこういうインターフェースになったのかは知らない．
型推論との兼ね合いな気はする (個人的には， 非常にまずい設計になっていると感じる)．
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Foreign.StablePtr</h2>
<div class="outline-text-2" id="text-7">
<p>
特定のポインタを明示的に GC の管理から外したいときに使う．
ものすごくパフォーマンスが重要な場合に使えるのかもしれない．
わたしは使ったことがない．
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Foreign.ForeignPtr</h2>
<div class="outline-text-2" id="text-8">
<p>
外部のポインタを GC に管理させたいときに使う．
これは便利．
</p>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Foreign.C</h2>
<div class="outline-text-2" id="text-9">
<p>
<code>Foreign.C</code> モジュールは C とのインターフェースとなる型を提供する．
</p>
</div>
</div>
</div>
</body>
</html>
