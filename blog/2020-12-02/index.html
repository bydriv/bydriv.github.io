<!DOCTYPE html>

<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/etc/site/style.css">
  <title>bydriv.github.io</title>
  <meta property="og:url" content="https://bydriv.github.io/blog/2020-12-02/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="bydriv.github.io" />
  <meta property="og:description" content="とりとめのない話 (閑話休題): ソフトウェアの設計と開発の複雑性についての雑記" />
  <meta property="og:site_name" content="bydriv.github.io" />
  <meta property="og:image" content="https://bydriv.github.io/etc/site/thumbnail.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <script type="text/javascript" src="/etc/site/kt.js"></script>
</head>

<div class="navigation"><!--
--><div class="left"><!--
--><a class="section" href="/">&#x221A;</a><!--
--><a class="section" href="/blog">&#x1F4DD;</a><!--
--><a class="section" href="/illustration">&#x1F3A8;</a><!--
--><a class="section" href="/photo">&#x1F4F7;</a><!--
--><a class="section" href="/literature">&#x1F516;</a><!--
--><a class="section" href="/world">&#x1F4BD;</a><!--
--><a class="section" href="/comic">&#x1F4AD;</a><!--
--><a class="section" href="/vr">&#x1F9E9;</a><!--
--><a class="section" href="/misc">&#x1F4C1;</a><!--
--></div>&nbsp;<!--
--><div class="right"><!--
--><a class="holoio section" href="#holoio">&#x22EF;</a><!--
--></div><!--
--></div><!--
--><div id="holoio">
<div class="navigation"><!--
--><div class="left"><!--
-->&nbsp;</div>&nbsp;<!--
--><div class="right"><!--
--><a class="section" href="#">&#x2573;</a><!--
--></div><!--
--></div>

<div class="kt-month-calendar" data-today="true"></div>
</div>

<article>
<h1 id="とりとめのない話-閑話休題-ソフトウェアの設計と開発の複雑性についての雑記">とりとめのない話 (閑話休題): ソフトウェアの設計と開発の複雑性についての雑記</h1>
<ul>
<li><em>(<a href="../2020-12-01">とりとめのない話 (3): 余園と創発について</a> の続き (？) / あんまり関係ないです (閑話休題) / 複雑系に興味がある)</em></li>
</ul>
<p>普段考えているとりとめのない話 (の言語化)。</p>
<h2 id="ソフトウェア開発の複雑性">ソフトウェア開発の複雑性</h2>
<p>Expression Problem という古典的な問題がある。これは実のところソフトウェア開発の複雑性をよく表した好例である。</p>
<p>x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub> を値、 f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> を関数としよう。</p>
<p><em>ソフトウェア開発を対象に考えているので、ここで言う値とか関数というのはひとつメタな話、つまり普通にプログラムで定義できる値や関数について <strong>も</strong> 考えているし、型クラスやトレイトなら型という値や型制約という関数について <strong>も</strong> 考えているし、メタプロの場合だと構文木という値やマクロという関数について <strong>も</strong> 考えている。 x<sub>i</sub>, f<sub>j</sub> が具体的になんであるかではなくその関係性を考えているわけである (メタのさらにメタな話なのでややこしいが)。</em></p>
<p>これらの (単純な) 組み合わせは次の 9 通りである。</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">f<sub>1</sub></th>
<th align="left">f<sub>2</sub></th>
<th align="left">f<sub>3</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">x<sub>1</sub></td>
<td align="left">f<sub>1</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>1</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>2</sub></td>
<td align="left">f<sub>1</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>2</sub>)</td>
</tr>
<tr class="odd">
<td align="left">x<sub>3</sub></td>
<td align="left">f<sub>1</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>3</sub>)</td>
</tr>
</tbody>
</table>
<p>無論 f<sub>1</sub>(f<sub>1</sub>(x<sub>1</sub>)) のような組み合わせも考えることができるのだが、そういうことは一旦忘れておく。</p>
<p>ともかく、上記の 9 通りがいずれも成り立つのは理想的な関係である。なぜかというと、これが成り立たないと Expression Problem が発生するからである。つまり新しい関数を仮に f<sub>4</sub> として</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">f<sub>1</sub></th>
<th align="left">f<sub>2</sub></th>
<th align="left">f<sub>3</sub></th>
<th align="left">f<sub>4</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">x<sub>1</sub></td>
<td align="left">f<sub>1</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>4</sub>(x<sub>1</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>2</sub></td>
<td align="left">f<sub>1</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>4</sub>(x<sub>2</sub>)</td>
</tr>
<tr class="odd">
<td align="left">x<sub>3</sub></td>
<td align="left">f<sub>1</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>4</sub>(x<sub>3</sub>)</td>
</tr>
</tbody>
</table>
<p>とするとき、もし f<sub>4</sub> ひとつ用意すれば済むのであれば作業量は O(1) だし新しい値を x<sub>4</sub> として</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">f<sub>1</sub></th>
<th align="left">f<sub>2</sub></th>
<th align="left">f<sub>3</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">x<sub>1</sub></td>
<td align="left">f<sub>1</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>1</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>2</sub></td>
<td align="left">f<sub>1</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>2</sub>)</td>
</tr>
<tr class="odd">
<td align="left">x<sub>3</sub></td>
<td align="left">f<sub>1</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>3</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>4</sub></td>
<td align="left">f<sub>1</sub>(x<sub>4</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>4</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>4</sub>)</td>
</tr>
</tbody>
</table>
<p>となれば作業量は O(1) である。</p>
<p>x<sub>i</sub> にそれぞれ専用の f<sub>i1</sub>, f<sub>i2</sub>, f<sub>i3</sub> があった場合、</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">f<sub>i1</sub></th>
<th align="left">f<sub>i2</sub></th>
<th align="left">f<sub>i3</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">x<sub>1</sub></td>
<td align="left">f<sub>11</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>12</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>13</sub>(x<sub>1</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>2</sub></td>
<td align="left">f<sub>21</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>22</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>23</sub>(x<sub>2</sub>)</td>
</tr>
<tr class="odd">
<td align="left">x<sub>3</sub></td>
<td align="left">f<sub>31</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>32</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>33</sub>(x<sub>3</sub>)</td>
</tr>
</tbody>
</table>
<p>となる。このとき f<sub>i4</sub> を追加しようと思ったら実装項目は f<sub>14</sub>, f<sub>24</sub>, f<sub>34</sub> で x<sub>4</sub> を追加しようと思ったら f<sub>41</sub>, f<sub>42</sub>, f<sub>43</sub> を実装せねばならない。値が n 個、関数が m 個あったとしたら関数を追加するのは O(n), 値を追加するのは O(m) でソフトウェア開発の複雑性は O(n*m) となる。仮に x<sub>i</sub> = 代数的データ型、 f<sub>j</sub> = 関数や x<sub>i</sub> = クラス、 f<sub>j</sub> = メソッドとしてみれば想像しやすいだろう。この意味で Expression Problem は上記の関係の特殊な場合だと言えるだろう。</p>
<p>もちろん n, m が小さいうちは問題なく開発できる。しかし n, m が増加すると作業量が爆発する。すると最終的には破綻するわけだ。</p>
<p><em>あくまで上記のような関係が <strong>局所的に</strong> 存在することは否定せずそのような関係であれば n, m を小さく保つこと、つまり、 n, m が増加する場合にどう開発するのが妥当かについて考えているわけである。もし n や m がとても小さな値でかつ定数である場合には問題にならない。しかし、 n, m が増加する場合はまったく別の考え方で開発する必要がある。</em></p>
<p>ソフトウェアの設計はデータ構造の設計である。ソースコードがデータ構造であるとすれば、プログラマはアルゴリズムである。関数や値の追加の計算量はデータ構造に対する操作そのものであり、その計算量はソフトウェアの設計によって決定する。データ構造が破滅していたら、操作をいくら最適化しても計算量はいつか頭打ちになるのである。</p>
<p>あるソフトウェアに関して</p>
<ul>
<li>機能追加</li>
<li>機能削除</li>
<li>機能変更</li>
<li>品質保証</li>
</ul>
<p>のよっつのオーダーを考えよう。このよっつのオーダーが O(1) であることがソフトウェアの理想状態である。</p>
<p>機能とは x<sub>i</sub> であったり f<sub>j</sub> かもしれない。だから上記の表で言えば、</p>
<ul>
<li>機能追加: 表の行か列を伸ばすこと</li>
<li>機能削除: 表の行か列を縮めること</li>
<li>機能変更: 表の行か列を変更すること</li>
<li>品質保証: 表のすべてのセルが正しく動作するか確かめること</li>
</ul>
<p>である。</p>
<p>ここで機能変更は通常、セルではなく行や列に対して一括で行う必要がある。このすべてを O(1) で行うことが可能なデータ構造の設計は容易ではない。</p>
<p>品質保証を O(1) ですることは簡単ではない。たとえば自動テストは n * m 回のテストを自動化できるが、 n * m 個の自動テストを書く必要はある。</p>
<p><em>あるいは組み合わせ次第では、単純な 2 次元の表ではなく 3 次元になっていたりする場合もあるだろう。値と関数ではなく値同士の関係性を考えたり、この考え方を 3 次元や 4 次元に拡張することはできるだろう。あるいはより一般化することもできるかもしれないが、今回は親しみやすい特殊な場合 (もっとも、それもマクロなども含めていろいろなものを代表しているわけで、いわゆる関数とは限らないのだが) として、値と関数という対象、そして関数適用という関係について考えようというわけである。</em></p>
<p>ソフトウェアの望ましい状態は</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">f<sub>1</sub></th>
<th align="left">f<sub>2</sub></th>
<th align="left">f<sub>3</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">x<sub>1</sub></td>
<td align="left">f<sub>1</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>1</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>2</sub></td>
<td align="left">f<sub>1</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>2</sub>)</td>
</tr>
<tr class="odd">
<td align="left">x<sub>3</sub></td>
<td align="left">f<sub>1</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>3</sub>)</td>
</tr>
</tbody>
</table>
<p>という状態である。この場合</p>
<ul>
<li>機能追加: O(1)</li>
<li>機能削除: O(1)</li>
<li>機能変更: O(1)</li>
<li>品質保証: O(1)</li>
</ul>
<p>となる。</p>
<p>品質保証が O(1) である根拠について述べておこう。まず品質保証を O(1) でするということは、たとえば自動テストを実行するというような (人間にとって) O(1) の操作を実行したらすべての i, j について f<sub>j</sub>(x<sub>i</sub>) の品質保証が可能であるということである。ここで自動テストの実行にいくら時間がかかるとかはあんまり関係ないということである。</p>
<p>そのためには自動テストを O(1) で書いたり変更したり削除したり必要がある。なぜならもし自動テストがメンテされなければ品質保証できているとは言わないからである。その方法は、 k を定数として</p>
<ul>
<li>f<sub>k</sub> を追加したとき、任意の i について f<sub>k</sub>(x<sub>i</sub>) の品質保証が可能なテスト t<sub>k</sub>(x<sub>i</sub>) も追加する</li>
<li>f<sub>k</sub> を削除したとき、任意の i について f<sub>k</sub>(x<sub>i</sub>) の品質保証が可能なテスト t<sub>k</sub>(x<sub>i</sub>) も削除する</li>
<li>f<sub>k</sub> を変更したとき、任意の i について f<sub>k</sub>(x<sub>i</sub>) の品質保証が可能なテスト t<sub>k</sub>(x<sub>i</sub>) も変更する</li>
</ul>
<p>ことである。このテストは x<sub>i</sub> や f<sub>j</sub> が増えても変わらず、 f<sub>i</sub> が追加されたり削除されたり変更されたときだけ定数個を追加したり削除したり変更すればいいので O(1) であると言える。 t<sub>k</sub> ひとつあれば</p>
<ul>
<li>for x<sub>i</sub> in x<sub>1</sub>, x<sub>2</sub>, .., x<sub>n</sub> do t<sub>k</sub>(x<sub>i</sub>) done</li>
</ul>
<p>とすればすべての x<sub>i</sub> をテストできる。従って O(1) で品質保証が可能であると言える。</p>
<p>テストの数という概念を考えてもいいが、問題は x<sub>i</sub>, f<sub>j</sub> の数が増えてもテストが網羅的であることである。 x<sub>i</sub>, f<sub>j</sub> の数が増えたとき、テストされていないセルがない状態が重要である。</p>
<p>ちなみに品質保証が O(1) であるというのは自動テストが網羅的に書かれていると仮定すれば成り立つ。しかしもし、たとえば f<sub>j</sub> を追加したとして、 x<sub>i</sub> の数だけその組み合わせのテストを書かなければいけない状況などでは f<sub>j</sub> の追加のオーダーがひどいことになる。機能追加のオーダーに O(n) を払えばたしかに品質保証は O(1) でできるかもしれないが、人間は怠惰なので機能追加してもテストを書かないだろう。</p>
<p><em>もしくは f<sub>j</sub> を形式検証していかなる x<sub>i</sub> についても f<sub>j</sub>(x<sub>i</sub>) が常に問題なく動作することを証明することもできるだろう (証明駆動開発)。証明は大変だろうが、やはり x<sub>i</sub>, f<sub>j</sub> の増減とは独立しているので O(1) であると言える。</em></p>
<p>このようなソフトウェアは機能追加、削除、変更、品質保証に対してスケールする。だからこういう状態を目指したい。</p>
<p>f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> : ∀a. a → .. (.. の部分はなんでもいい) が多相的な場合、上記のような状態は自明に成り立つ。</p>
<p>では、ほかの場合で上記のような状態が成り立つことがあるか考えてみよう。</p>
<h2 id="top-型について">Top 型について</h2>
<p>Top という型がある。詳しくは TaPL を読もう。かいつまんで言えばいかなる型 T に関しても</p>
<pre><code>T &lt;: Top</code></pre>
<p>という関係が成り立つ型である。ここで <code>&lt;:</code> は部分型関係である。</p>
<p><em>なぜここで型が出てくるのか？　メタプロを対象として考えるならば当然その型を考えることができる (通常、たとえばマクロは untyped だが)。この型を本当にプログラミング言語で表現する場合、メタプロを値レベルでする、もしくは型レベルで計算して型の型で型システムを拡張する必要がある (型システムがチューリング完全になったり型の型が単純で表現力に乏しかったりしがち)。静的型つき言語で実行時メタプロするとフルの型システムが使えて実行時メタプロに静的に型がついてうれしい (ほんまか)。この場合は型を表す値を静的型つき言語で定義する必要がある (コンパイラなどを書いたことがあれば、型を表す値を定義すること自体は自然なのはわかると思う)。</em></p>
<p>(いわゆる部分 <strong>型つけ</strong> がない言語に関しても部分型 <strong>関係</strong> は考えることはできるので、安心してほしい)</p>
<p>さて部分型 <strong>関係</strong> に対していわゆる部分 <strong>型つけ</strong> と呼ばれている推論規則は</p>
<pre><code>T &lt;: S    x : T
---------------
     x : S</code></pre>
<p>というものである。これは <strong>包摂</strong> (<em>subsumption</em>) と呼ばれる推論規則である。つまり <code>T &lt;: S</code> という関係が成り立つときはいつでも <code>x : T</code> ならば <code>x : S</code> を結論してよいということである。</p>
<p>仮に <code>T = {a : int, b : int}</code>, <code>S = {a : int}</code> とすれば</p>
<pre><code>{a : int, b : int} &lt;: {a : int}    x : {a : int, b : int}
---------------------------------------------------------
                      x : {a : int}</code></pre>
<p>となる。これがいわゆる部分 <strong>型つけ</strong> と呼ばれるものである。</p>
<p>これに対して部分型 <strong>関係</strong> は上記の推論規則がない言語に関しても考えることはできる。たとえば明示的にキャストできる言語があったとしよう。 <code>x : T</code> として <code>x as S</code> の妥当性を考えるときに <code>T &lt;: S</code> という関係を考えることができるだろう。たとえば <code>i32 &lt;: i64</code> はたしかに妥当な関係に思える。 <code>f32 &lt;: f64</code> はどうだろうか。ともかく、部分型関係について考えることは必ずしも (いわゆる) 部分型つけについて考えるわけではないことは強調しておきたい。</p>
<p>さてここで Top 型の話に戻ろう。 Top とはいかなる T をとっても</p>
<pre><code>T &lt;: Top</code></pre>
<p>となる型であるとは先に述べた。ここで全称量化 <code>∀x. T</code> は</p>
<pre><code>∀x. T ⇔ ∀x &lt;: Top. T</code></pre>
<p>の関係が成り立つ。このように全称量化を拡張したものは有界量化と呼ばれる。型クラスやトレイト境界はたぶん有界量化だろう (知らんけど)。</p>
<h2 id="ソフトウェアの設計は問題領域を設計するということ">ソフトウェアの設計は問題領域を設計するということ</h2>
<p>さて上記で Top とはなんであるかを述べた。ここでソフトウェアの設計の話に戻ろう。</p>
<p>ソフトウェア望ましい状態は</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">f<sub>1</sub></th>
<th align="left">f<sub>2</sub></th>
<th align="left">f<sub>3</sub></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">x<sub>1</sub></td>
<td align="left">f<sub>1</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>1</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>1</sub>)</td>
</tr>
<tr class="even">
<td align="left">x<sub>2</sub></td>
<td align="left">f<sub>1</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>2</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>2</sub>)</td>
</tr>
<tr class="odd">
<td align="left">x<sub>3</sub></td>
<td align="left">f<sub>1</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>2</sub>(x<sub>3</sub>)</td>
<td align="left">f<sub>3</sub>(x<sub>3</sub>)</td>
</tr>
</tbody>
</table>
<p>という状態であることは先に述べた。</p>
<p>このような関係が成り立つのはある唯一の型 T が存在して x<sub>1</sub> : S<sub>1</sub>, x<sub>2</sub> : S<sub>2</sub>, x<sub>3</sub> : S<sub>3</sub>, S<sub>1</sub> &lt;: T, S<sub>2</sub> &lt;: T, S<sub>3</sub> &lt;: T, f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> : ∀ a &lt;: T. a → .. となる場合である。</p>
<p>もちろん f<sub>i</sub> が部分写像でない前提。つまり f<sub>i</sub> の定義域はすべて定義されている (左全域的である)。</p>
<p><em>(なお x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub> : T かつ f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> : T → .. でもよい。これは特殊な場合として導ける)</em></p>
<p>さて任意の値や関数について考えるならば、 T = Top でしかない。つまり値や関数は無数に追加できるわけで、常に f : ∀a &lt;: Top. a → .. でしかない。</p>
<p>しかしこれでは a に関して言える性質がほとんどないので、意味のあるソフトウェアを開発することが難しい。あなたの問題領域において適切に制限した T となるような型を考えることで、意味のあるソフトウェアを開発できるのである。</p>
<p>では仮に、そのような型 T を <strong>問題領域</strong> (<em>domain</em>) と呼んだとしよう。ここで</p>
<p><strong>ソフトウェアの設計とは問題領域の設計である。</strong></p>
<p>と言える。</p>
<p>つまり</p>
<pre><code>S &lt;: T</code></pre>
<p>となるような S があなたのソフトウェアが問題としている領域である。</p>
<p>つまりもしあなたのソフトウェアにおける問題領域を設計できたとしよう。そしてすべての関数を f : ∀a &lt;: T. a → .. と実装できたならばソフトウェアの開発の機能追加や削除、変更のオーダーは O(1) になるのである。</p>
<p>そこで</p>
<pre><code>S &lt;: T かつ x : S</code></pre>
<p>であることを x は問題領域 T に属すると言い</p>
<pre><code>f : ∀a &lt;: T. a → ..</code></pre>
<p>というような関数を T を問題領域とする関数と言うことにしよう。</p>
<p>すべての値が問題領域 T に属し、すべての関数が T を問題領域とするときが理想状態と言える。</p>
<p>ただし T を考えるときには性質について考える必要がある。つまりもしある T を設計したとして、新しく追加した x<sub>i</sub> や f<sub>j</sub> に関して言える性質がなんであるかを考える必要がある。つまり</p>
<ul>
<li>もし x<sub>i</sub> &lt;: T, f<sub>j</sub> : ∀a &lt;: T. a → .. と仮定するならば f<sub>j</sub>(x<sub>i</sub>) でできる処理とはどのようなものが考えられるだろうか？</li>
<li>x<sub>i</sub> や f<sub>j</sub> の具体例として、どんなものが、いくつくらい考えられるだろうか？</li>
</ul>
<p>について考えよう。</p>
<p>強い性質を述べるためには、 T に強烈な制限をつける必要がある。しかしもしそのような T を設計できたならばソフトウェア開発は劇的に楽になるであろう。</p>
<p>T の制限を緩めるということは、</p>
<ul>
<li>もし x<sub>i</sub> &lt;: T, f<sub>j</sub> : ∀a &lt;: T. a → .. と仮定するならば f<sub>j</sub>(x<sub>i</sub>) でできる処理とはどのようなものが考えられるだろうか？</li>
<li>x<sub>i</sub> や f<sub>j</sub> の具体例として、どんなものが、いくつくらい考えられるだろうか？</li>
</ul>
<p>という関係において、言える性質が弱くなるということである。</p>
<p>つまり S &lt;: T であるような S を広くする一方で、上記の性質は弱くなる。もちろん強い性質を言える T もあり、そのような T に関するソフトウェアはライブラリと言われる。一方でアプリケーションは T に強い制限をつけたソフトウェアであると言える。</p>
<ul>
<li>ライブラリとは T に仮定するもの制約が少なく、かつ強い性質を言えるものである</li>
<li>アプリケーションとは T に仮定する制約が多く、かつ強い性質を言えるものである</li>
</ul>
<p>T に仮定する制約が少ない (あるいは多い) からと言って強い性質を言えるとは限らないことに注意は必要である。制約は性質を言うためにあり、言える性質が弱いならば制約をつける意味はない。制約が弱くても弱い性質しか言えないならばその制約は妥当ではないし、制約が強くても強い性質を言えるならばその制約は妥当なのである。</p>
<p>早すぎる抽象化という言葉がある。これはなんらかの制約を考え抽象化したはいいが、言える性質が少ないということである。</p>
<p>一般に、強い制約をつけて強い性質を言うのは容易である。一方で弱い制約をつけて強い性質を言うのは困難である。</p>
<p>ライブラリにできないのは、強い制約を満たすものは基本的に少ないからである。つまりあらゆるソフトウェアにおいて汎用性があるライブラリをつくるには、制約を弱くする必要がある。</p>
<p>しかしある特定の、具体的なアプリケーションを開発する場合には強い制約を満たすものは多くある。アプリケーションは複数のモジュール、複数の関数、複数の値からなり、その特定のアプリケーション内の複数のモジュール、複数の関数、複数の値は強い制約を満たすかもしれない。というよりも、あらかじめ T という強い制約を先に定義しておき、それを満たすように設計すべきであろう。これはスクラッチで書く場合は容易だがそうでない場合は難しい。</p>
<p><em>なお、個人的な経験則では T は関数を含まない型にすることがおすすめである。関数は通常シリアライズできない。もし T が json にシリアライズ可能であれば x<sub>i</sub> を設定ファイルにできるので、ソフトウェアはとても柔軟で拡張性の高いものになる。それにランダムテストが可能だったりして、テストを書くのも比較的簡単である。</em></p>
<p><em>また T &lt;: S であるような S があったとして、 f<sub>j</sub> の <strong>実装</strong> が T ではなく S を仮定していたとしよう。このとき f<sub>j</sub> : ∀a &lt;: S. a → .. と定義するのはおすすめしない。 f<sub>j</sub> の <strong>実装</strong> ではなく <strong>仕様</strong> が仮定しているものが不明である。あくまで型は実装ではなく仕様を書くべきである。つまり f<sub>j</sub> の <strong>仕様</strong> が T を仮定しているなら、 f<sub>j</sub> : ∀a &lt;: T. a → .. と書くべきである。</em></p>
<h2 id="モジュールの分割単位について">モジュールの分割単位について</h2>
<p>次はモジュールについて考えてみよう。ある型 T と n 個の値と m 個の関数からなる集合を</p>
<ul>
<li>M<sub>Tnm</sub> = {x<sub>1</sub>, x<sub>2</sub>, ..x<sub>n</sub>, f<sub>1</sub>, f<sub>2</sub>, .., f<sub>m</sub>}</li>
</ul>
<p>と表し、これをモジュールと呼ぼう。</p>
<p>すべての x<sub>1</sub>, x<sub>2</sub>, .., x<sub>n</sub> が問題領域 T に属し、すべての f<sub>1</sub>, f<sub>2</sub>, .., f<sub>m</sub> が T を問題領域とする関数ならば、そのモジュールの問題領域は T であるとか、 T を問題領域とするモジュールであるとか、 M の問題領域は適切であるとか言おう。</p>
<p>次に考えるべきはモジュールの適切な分割単位である。</p>
<p>あるモジュール内において問題領域が適切でも、ほかのモジュールと密結合であればソフトウェア開発は複雑になる。モジュールは疎結合でなければならない。</p>
<p>M<sub>Tn<sub>1</sub>m<sub>1</sub></sub>, M<sub>Sn<sub>2</sub>m<sub>2</sub></sub> をモジュールとしよう。</p>
<p>M<sub>Tn<sub>1</sub>m<sub>1</sub></sub> と M<sub>Sn<sub>2</sub>m<sub>2</sub></sub> とが<strong>疎結合である</strong> とは n<sub>1</sub>, m<sub>1</sub> と n<sub>2</sub>, m<sub>2</sub> との間に依存関係がないことである。</p>
<p>疎結合であるモジュールの分割単位を <strong>適切な分割単位</strong> を言おう。</p>
<p>依存関係の概念を定式化するのは難しいが直観的に言えば</p>
<ul>
<li>n<sub>1</sub>, m<sub>1</sub> が増減しても n<sub>2</sub>, m<sub>2</sub> が増減する必要はないこと</li>
<li>n<sub>2</sub>, m<sub>2</sub> が増減しても n<sub>1</sub>, m<sub>1</sub> が増減する必要はないこと</li>
</ul>
<p>つまりまったくの無関係であるということである。</p>
<p>もし M が T を問題領域とするモジュールならば、 n<sub>1</sub> が増減しても m<sub>1</sub> が増減する必要はないこと、また m<sub>1</sub> が増減しても n<sub>1</sub> が増減する必要はないことは明らかである。というよりも、値と関数とを疎結合にするというのが最初の定義であったと言ってもいい。</p>
<p>従って</p>
<ul>
<li>M<sub>Tn<sub>1</sub>0</sub> = {x<sub>1</sub>, x<sub>1</sub>, .., x<sub>n<sub>1</sub></sub>}</li>
<li>M<sub>T0m<sub>1</sub></sub> = {f<sub>1</sub>, f<sub>2</sub>, .., f<sub>m<sub>1</sub></sub>}</li>
</ul>
<p>も疎結合である。値と関数を分割したモジュールも疎結合であり、適切な分割単位である。モジュールの分割単位は問題領域ではなく疎結合であることにある、とも言える。</p>
<p>ただ現実的には、値と関数がここまで理想的に分離できることはそうそうない。そういった場合のことまで考え始めると時間はないが、一般原則としては、密結合であるような値と関数は同じモジュールでまとめ、あくまでモジュール間は疎結合に保つべきだろう。</p>
<p>そのような場合は適当な型を考えて</p>
<ul>
<li>M<sub>⊥nm<sub></li>
</ul>
<p>とでも表せばいい。</p>
<p>M が ⊥ を問題領域としていないならば、その関数にはなんの制約もないということである。</p>
<p>このようなモジュールを増やしすぎるのはよくないが、あくまでこのようなモジュールが仮にあったとしても、密結合になる値と関数はひとつのモジュールに押し込めるべきであろう。</p>
<p>仮にすべてのモジュールの問題領域が適切で、かつすべてのモジュールが疎結合であれば幸いである。</p>
<h2 id="おまけ-公理定理具体例-または公理による演繹な開発-あるいは弱い力と強い力の分離すること">おまけ: 公理、定理、具体例 / または公理による演繹な開発 / あるいは弱い力と強い力の分離すること</h2>
<p>ところで Expression Problem は上記の関係で解決されていると言えるだろう。</p>
<p>そこで自明な系として</p>
<p>x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub> : T かつ f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> : T → .. であれば Expression Problem は解決できる。</p>
<p>が従う。有界量化を言語機能として持つ言語はあまりないが、単相な値や関数を定義できる言語は多くある。関数が値であることさえ仮定していないので、関数が第一級である必要すらない。考え方として、かなり広範な言語に応用可能だ。</p>
<p><strong>想定される質問</strong>: そうは言っても T を変更したらたくさん変更しなくちゃいけないのではないか。</p>
<p><strong>答え</strong>: 実際そうで、だから T を変更に強く設計しなければならないわけである。そしてそれがソフトウェアを設計するということだ、ということの意味でもある。</p>
<p>たとえば T を代数的データ型で定義するのは愚策である。もし</p>
<pre><code>data T = X | Y</code></pre>
<p>と定義すれば x<sub>1</sub> = <code>X</code>, x<sub>2</sub> = <code>Y</code> となる。しかし x<sub>3</sub> = <code>Z</code> を増やすためには T の定義を <code>data T = X | Y | Z</code> と変更する必要がある。ここで T を変更せずに x<sub>3</sub> = <code>Z</code> をいかにして増やすかが腕の見せ所であろう。そして、 f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> も、 x<sub>3</sub> を増やしても f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub> の定義を変更せずに f<sub>1</sub>(x<sub>3</sub>), f<sub>2</sub>(x<sub>3</sub>), f<sub>3</sub>(x<sub>3</sub>) に関しても問題なく (そして単に無視するのではなく期待通りに) 動作しなければならない。</p>
<p>おっと、では T を多相バリアントで定義しようとは思わないでほしい。多相バリアントは</p>
<pre><code>[`X | `Y] &lt;: [`X | `Y | `Z]</code></pre>
<p>であることに注意しよう。 T を変更せずに x<sub>3</sub> = <code>Z</code> を増やすことは容易なことではないのである。</p>
<p>型クラスやトレイトでの定義は、有望だ。ただし型クラスやトレイトをいかにして定義するかはかなり実力が試される。</p>
<p>T は公理と言えるだろう。公理を変更すればすべてが破綻するのは当然である。いわばこれは公理を置いて演繹的に開発するということでもある。</p>
<p>f<sub>j</sub> は T の定理であり、 T という公理を定義したことで言える性質であり、もっとも重要な存在である。</p>
<p>x<sub>i</sub> は T の具体例であると言えるだろう。</p>
<p>もしうまく T を定義できればとても豊かな世界が展開できる。</p>
<p>そこで T を具体的に構成することは、演習問題としよう。求められる性質は T の定義を変更せずに x<sub>i</sub>, f<sub>j</sub> をいかに追加するか、である。</p>
<p>わたしは次のような性質をもつような設計が好みである:</p>
<ul>
<li>f<sub>j</sub> は強い力をもつ。 f<sub>j</sub> は制御できない。 f<sub>j</sub> は非自明である。 f<sub>j</sub> の構成は困難である。 f<sub>j</sub> は手続き的である。 f<sub>j</sub> はテストする。 f<sub>j</sub> はシリアライズできない。 f<sub>j</sub> はチューリング完全である。 f<sub>j</sub> は一般的であり抽象的である。 f<sub>j</sub> はメタ世界で定義される。 f<sub>j</sub> は矛盾しうる。</li>
<li>x<sub>i</sub> は弱い力をもつ。 x<sub>i</sub> は制御できる。 x<sub>i</sub> は自明である。 x<sub>i</sub> の構成は容易である。 x<sub>i</sub> は宣言的である。 x<sub>i</sub> はテストしない。 x<sub>i</sub> はシリアライズできる。 x<sub>i</sub> はチューリング完全ではない。 x<sub>i</sub> は特殊であり具象的である。 x<sub>i</sub> は対象世界で定義される。 x<sub>i</sub> は無矛盾である。</li>
</ul>
<p>具体例を関数にしたり、汎用言語にしたり、万能な DSL にしたり、とにかく <strong>なんでもできる</strong> ようにしたいというのは悪魔の誘惑でありぐっとこらえなければならない。具体例はあくまで <strong>設定</strong> (<em>configure</em>) であるべきだ。設定は宣言的であり、人間が見て理解できる限界である。</p>
<p>数学の公理や定理と違うのは、ソフトウェアは具体例があって初めて動作するものであるということである。だからここで T というものをあまり過度に一般的に定義しても、あまり意味のあるソフトウェアは開発できない。あまりにも過度に一般的に T を定義すると、具体例を構成するのが大変すぎるのである。</p>
<p>一方で T を定義せずに開発を進めるということは、すべてをメタ世界で定義するということでありソフトウェアのありとあらゆる場所がチューリング完全で矛盾しうる、なんの規則も秩序もない混沌とした荒野をさまようということである。</p>
<p>公理、定理、具体例の責務をどう分類するかがソフトウェアを開発するうえでの能力と言ってもいいと思う。あるソフトウェアを開発するためには、最終的には具体例を構成しなければならない。もし責務を具体例に押し付けたり、逆に定理に押し付けすぎると最終的にはあなたが苦しむことになる。</p>
<h2 id="ひとつの例-ゲーム開発">ひとつの例: ゲーム開発</h2>
<p>たとえば T がゲームエンジンだと、具体例を構成するためにはゲームを開発しなければならないわけである。これはこれで意味のある公理系ではあるものの、基本的に具体例を構成することが難しいということは、また別に新たな公理系を考える必要がある。</p>
<p>公理系には階層がある。ライブラリだとかゲームエンジンを開発するときに置く公理は、具体例をできるだけ広く、汎用的になるように定義する。このような公理系の具体例を構成するのは大変だが、汎用的で有用なものである。</p>
<p>一方でアプリケーションを開発する場合、具体例の構成が負担になることが多い。さらにここで置く公理系というのは階層を根が言語機能だとか標準ライブラリであるような木構造だとすれば葉の部分、つまりそれ以上なにかが派生するものではない。だから具体例が汎用的になるようにする必要はなく、具体例が自明になるような公理を置くことは、理に適っている。</p>
<p>たとえば T がゲームのオブジェクトであれば、具体例は設定だけで構成できる。</p>
<p>わたしの場合は、このとき定理はあくまでゲームのオブジェクトの処理に徹し、具体例はあくまでゲームのオブジェクトの構成に徹するように責務を分離する。</p>
<p>ここでもし定理が <strong>もし具体例にこういうメソッドが定義されていたら</strong> と仮定した瞬間に、その定理は処理の責務を具体例に押し付けてしまっている。関数を仮定すれば定理を汎用的にするのは簡単だけど、具体例の構成が難しくなる。結局だれかが具体例を構成しなければソフトウェアは動作しないので、責務を定理が担保するか具体例が担保するかは、設計者のセンスが問われるところだと思う。</p>
<h2 id="ひとつの例-restful-api">ひとつの例: RESTful API</h2>
<p>RESTful API の場合はどうだろうか？　もし T がすべての API を表す型クラスで、エンドポイントの設定を記述するだけで定理により自動的に動くものができたらどうだろうか。</p>
<p>これはとても強い性質で、こういうことを言うためにはおそらく、たとえば公理には JSON Schema を持っているとか、そういう仮定が必要だろう。</p>
<p>もちろん現実にはロジックが共通でない場合も多く、そう理想的にはいかないだろう。原理的にまとめることが難しいものもあるが、基盤となる公理を置かず、無秩序に開発してしまって結果的にまとめるのが難しいだけの場合もある。たとえば GET, PUT という操作が単純にデータベースに登録するだけでなく非自明な操作をしていることもあるし、おそらく普通はそうだろう。こういうものは、無理にまとめないほうがいい。現に動いていることは大事だし、無理にまとめてかえってバグるくらいなら、現に動いているものを運用することに注力すべきだ。</p>
<p>ただ、もし最初からまとめる前提で設計していたとすれば、そうすることは可能だろう。</p>
<p>たとえば GET, PUT というのは、あくまでデータベースに保存するのが役目である、と公理で仮定したとしよう。多くの場合リクエストで受け取った値をそのまま (バリデーションはするにしても) 保存すればいいのだろう。公理で仮定すべきはエンドポイントの存在と JSON Schema の存在、あるいは、ユーザという概念があるならばユーザがログイン済みでないと使用できないかどうか、ログイン済みだとしてどういう権限があれば使用できる API か。これらの公理を置けば、 API とはユーザがある種の権限を持っている場合に利用できて、 PUT はバリデーションのあと単にそのままデータベースに保存するだけの操作であり、 GET とはデータベースの値をそのまま返すだけの操作であるという定理が導ける。</p>
<p>では非自明な操作はどうするのが妥当だろうか？</p>
<p>ひとつの考え方としては GET, PUT とデータベースの間に変形操作を差し込めるという公理を置く。変形操作は純粋な関数である。これは State モナドにおける modify の定義にも似ている。これはわたし流に言えば責務を具体例に押し付けている気はするものの、現実的な解ではあるだろう。</p>
<p>このように公理を置いて演繹的に開発すれば、おそらく API の体系もとてもわかりやすく、規則的かつ秩序だっているものになると思う。</p>
<h2 id="むすびに">むすびに</h2>
<p>ただ、正直これをライブラリにするのは難しいと思う。仮にライブラリにしたとして、そのライブラリでできる以上のことをしたいことは常にある。つまりその公理から導けないことをしたいということは、公理を拡張するか、公理に平伏して諦めるか、その公理系を窓から投げ捨てるしかない。</p>
<p>ライブラリのユーザは公理の拡張も平伏もできない。<strong>「公理」には逆らわず……受け入れたほうが……楽なのに……。</strong>だから窓から投げ捨てるしかないし、ゆえにライブラリにすることは難しいのである。</p>
<p>ただ、あなたの世界で公理を置けば、拡張もできるうえに通常は、その公理が正しいと思ってその公理を置いているわけだから、平伏して <strong>公理から導けないことをしたい自分のほうが間違っていたのだ！</strong> と納得できるわけである。公理様は完璧で幸福であり、その公理に平伏することは幸福であり幸福は義務である。あなたは幸福ですか？</p>
<p>とはいえ公理を置くこと自体を諦めるよりは、ライブラリにすることは諦めたうえで、個々のアプリケーションにおいて公理を置いて設計することが妥当だろう。その公理に従って設計されるからこそ秩序が生まれ、規則が生まれ、わかりやすくてきれいなものになるのである。</p>
<p>通常のフレームワークは、汎用的に設計される。つまりチューリング完全で、万能で、できないことなどなにもないように設計される。これは諸刃の剣である。</p>
<p>公理を置いて演繹的に開発するということは、なにができてなにができないかを決めるということでもある。そしてそれがその体系における世界観であり、秩序である。重要なのは <strong>なんでもできるようにはしないこと</strong> である。そして仮に公理を置けば、開発のオーダーも劇的に下がるのでいいこと尽くめである。<strong>自由は屈従である。</strong></p>
<p>もちろん、公理を置いて演繹的に開発するという考え方と、開発のオーダーを下げるという考え方は別の話である。</p>
<p>ただ、関係はある。公理を置いて演繹的に開発すれば開発のオーダーは下がる。なぜなら、公理を置いて演繹的に開発することは開発のオーダーを下げるための十分条件だからである。公理を置いて演繹的に開発すれば自動的に定理と具体例が疎結合になるから、開発のオーダーは下がる。</p>
<p>一方で開発のオーダーを下げるためには、要は関数と値が疎結合であればよいわけで、そのためにとれる方法は公理を置いて演繹的に開発することだけではないだろう。この意味で開発のオーダーを下げることは公理を置いて演繹的に開発することの必要条件であると言える。</p>
<p>矛盾しうるメタ世界のなかにいかにして無矛盾な対象世界を定義し、その対象世界の言葉でどれだけ意味のある、豊かな表現ができるか。</p>
<p>このような方針で設計されたソフトウェアはおそらく高品質で、かつスピーディに開発が可能であろう。 <em>(Con Con Con Con Con Con Con Con Conjecture (そんな言葉は使う必要がねーんだ) (Con Con ラッシュ 🦊))</em>。</p>
<p><em>(to be continued...?)</em></p>
</article>
