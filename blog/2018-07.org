#+SETUPFILE: ../setup.org
#+TITLE: 2018-7 の進捗まとめ

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>2018-07.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-08-04">2018-08-04</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-08-04">2018-08-04</time>@@
#+END_UPDATED_AT

[[./2018-06.org][2018-02 から 2018-6 の進捗まとめ]] の続き．

最近は [[./../log/index.org][bydriv.github.io/log]] にやったことをこまめに書いているので，
なにをやったか思いかえしやすい．

こういうふうになにをやったか書いておくのは，
あとあとあのときなにをやっていたのか思いだすために便利だと思った．
泳ぎ続けなければならないマグロのように，
常になにかをしていなければいけないというような焦りを感じるのだけど，
その根本的な原因は，過去の自分を肯定できないことにある気がする．
過去の自分を肯定できれば，現在すこしくらい怠けてもいいと思うのだけど，
そうできないから，現在の自分がなにかをしなければならないと思う．
ともかく，そのときにやっていたことをちゃんと記録しておくと，
なんだ，わたしってけっこういろいろすごいことやってるじゃん，
というふうに，自己肯定感をもちやすくなる気がする．

* 2018-07-01 .. 2018-07-18

七夕絵を描いたり，スニーカーサンダル絵を描いたりしていた．
あとゲームもやったり．うん． まあそんな感じ．

* 2018-07-18 .. 2018-08-04

7月分の進捗まとめだけど8月4日に書いているので，
8月4日までのことも含めて書いておく．

この時期は技術書典に応募するためにラムダ計算実装本を書く，
……ために Lamb という処理系を書いていた．

で，まだ 3週間も経っていないけどかなりいろいろな機能をもつにいたった．

できたこと:

- x64 コード生成
- Mark & Sweep GC
- Krivine Machine
- 遅延評価 (call-by-name)
- 型推論
- let 多相
- クロスコンパイル
- 分割コンパイル
- FFI

という感じで，まあまあふつうのコンパイラに必要な機能はだいたい揃った気がする．

Lamb はもともと， ラムダ計算実装本のサンプルコードとして実装を始めた．
なので最初は簡単なインタプリタ実装にするつもりだった．
ただいざ実装を始めると筆がのってしまったというかなんというか，
実装が楽しくて，けっこういろいろやってしまった．

それでも言語仕様はコンパクトなので，
実装も本のサンプルコードに載せられるくらいコンパクトなものになっている．

* おまけ: Lamb について

言語仕様としては，ほとんど単なる単純型つきラムダ計算である．
式も変数，適用，抽象， let しかない．
単純型つきラムダ計算には let はないが，
~let x := M in N~ を ~(^x.N)M~ の略記にしてしまうと，
~x~ が多相になれるかなれないかという違いがあるので，
いわば単純型つきラムダ計算を let 多相で拡張した体系ということになる．
式とはべつに宣言という概念もあり，
これは ~type~, ~val~, ~def~ のみっつがある．
これははつぎのような ~C(decls)~
という変換を考えれば式だけで同等な表現が可能になるので，
本質的な拡張ではない．

#+BEGIN_EXAMPLE
C(nil) := main
C(type t :: decls) := (^_ : t -> t. C(decls))(^x.x)
C(val x : T :: decls) := let x : T := y in C(decls)
C(def x [: T] := e :: decls) := let x [: T] := e in C(decls)
#+END_EXAMPLE

ただし ~val~ 宣言の変換における ~y~ は処理系が自動生成する外部変数への参照とし，
任意の型をもつものとする．
(この外部変数への参照は，単にプログラム全体のどこでも定義されていない自由変数が出現したときに
そういう扱いにすればよいので，式を拡張する必要はない．
しかし実際にそういうふうに実装してしまうと，ただ単に typo しただけでも
外部変数への参照になってしまうので，基本的に不便であると考えられるため，
こういう実装になっている．)

それほどコンパクトな言語仕様にもかかわらず，
FFI があるのでそれなりに現実的なプログラムも書けるようになっている．

ところで， FFI はいわば仮定を追加する機能である． FFI という言語機能がある場合，
健全性や無矛盾性をどう保つかということについて以前いろいろ考えていたのだが，
健全性や無矛盾性は FFI がまったくない場合，
あるいは，あるとしてもそれらが健全かつ無矛盾である場合にいえればよい， という結論に至った．
数理論理学でいくつかの仮定をすればある体系である定理が証明可能なことを
α_1,…,α_n ⊢β
のように書くが， この
α_i
という部分を追加するのが FFI であり，
Lamb でいうところの ~val~ 宣言である．
もし Lamb をひとつの形式体系と考えて，
無矛盾性や完全性などの証明をするならば，
~val x : T~
と宣言された部分は，もし ~T~ の真理値が ⊤ ならば
プログラム全体の真理値も ⊤ である，
というふうにすればよい．
