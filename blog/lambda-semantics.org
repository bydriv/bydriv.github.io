#+SETUPFILE: ../setup.org
#+TITLE: 型なしラムダ計算の (small step | big step) semantics  について

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>lambda-semantics.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-06-04">2018-06-04</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-06-04">2018-06-04</time>@@
#+END_UPDATED_AT

型なしラムダ計算の (small step | big step) semantics  について，
勉強したことを雑にまとめておく．

最近， 技術書典にラムダ計算本をだそうと思っていろいろ活動している．
書籍版ではちゃんとした証明をやろうと思うが， なかなか簡単にはできないので，
このブログで重要な定理などについて触れておく．

* 構文

まず構文について．これはウィキペディアにも載っているのでよく知られていると思うが，
通常型なしラムダ計算のラムダ項（の構文）は次のように定義される．

| /e_1/, /e_2/ | ::= | /x_1/           |
|              |     | (/e_1/ /e_2/)   |
|              |     | (λ /x_1/ /e_1/) |

λ /x_1/ . /e_1/ のようにドットをつけて定義するひともいるが，
あまり重要なことではない．

* 意味論

構文だけでは（型なし）ラムダ計算という体系についてちっともわかった気がしない．
というか，わからない．もちろん人間の脳は推測を得意としているので，
なんとなくこう実行されるのだろうというのはわかるだろうが，
コンピュータにはわからないし， 人類が滅びたあと地球を探査しにきた何者かにもわからない．
なんの前提知識もなしに（型なし）ラムダ計算という体系の意味を説明するのが意味論である．

意味論は説明のためのものなので，説明の方法はいろいろある．
操作的意味論は比較的よくもちいられる意味論である．
操作的意味論にも small step semantics と big step semantics の区別がある．
まずは "よりインタプリタの実装に近い" big step semantics について触れよう．

** big step semantics

big step semantics というのは要するに eval の実装であると考えればよい．
ほんとはいろいろ定義しなくちゃいけないのだがキモとなるのは次の適用に関する推論規則である．

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
/e_1/
⇓
(λ /x_1/ /e_3/)
#+END_PREMISE
#+BEGIN_PREMISE
/e_2/
⇓
/v_1/
#+END_PREMISE
#+BEGIN_PREMISE
([ /v_1/ / /x_1/ ] /e_3/)
⇓
/v_2/
#+END_PREMISE
#+BEGIN_CONCLUSION
(/e_1/ /e_2/)
⇓
/v_2/
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

⇓
という記号が eval 関数を意味していると考えればよい．
これは要するに (/e_1/ /e_2/) という項を評価する場合，
/e_1/ と /e_2/ を両方評価したうえでそれを代入し，
さらにそれも評価して値を返すという関数を定義している．

値とはなんぞや？　と気づかれた方は鋭い．
big step semantics では通常， 項とは別に値というものを定義する．
値の定義の仕方はいろいろあるが，とにかくそれ以上評価が進まない感じに定義する
（クロージャで定義することが多いようだ）．

** small step semantics

small step semantics はインタプリタっぽくはない，
若干理論寄りの定義である． big step semantics と比べると定義がすっきりしているほか，
無限ループの扱いなどがしやすいらしい（正直伝聞で聞いただけなのだが）．

肝心の定義は "1ステップの簡約" と "nステップの簡約" をべつべつに定義する感じにする．
具体的には，

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
#+END_PREMISE
#+BEGIN_CONCLUSION
((λ /x_1/ /e_2/) /e_1/)
▷_1
([ /e_1/ / /x_1/ ] /e_2/)
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
/e_1/
▷_1
/e_2/
#+END_PREMISE
#+BEGIN_CONCLUSION
(/e_3/ /e_1/)
▷_1
(/e_3/ /e_2/)
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
/e_1/
▷_1
/e_2/
#+END_PREMISE
#+BEGIN_CONCLUSION
(/e_1/ /e_3/)
▷_1
(/e_2/ /e_3/)
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
/e_1/
▷_1
/e_2/
#+END_PREMISE
#+BEGIN_CONCLUSION
(λ /x_1/ /e_1/)
▷_1
(λ /e_2/)
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

というふうに "1ステップの簡約" をまず定義する．
▷_1
が 1ステップの簡約を表す記号である．
なにがどう 1ステップなのかというと，
これらの規則をいくら組みあわせても最初の (適用の) 規則を 2度使うことができないということである．
うそだと思うのなら実際に手を動かして確かめてみよう．
正直重要なのはいちばん最初の規則だけで，
ほかの規則はどの部分項を簡約してもよい
(ラムダ項を抽象構文木として見たときに，どの位置で簡約してもよい)
ということを定めているだけである．
なお，前提の部分が空の推論規則は伝統的な論理学では公理として定義されることが多く，
計算機科学だと前提が空の推論規則として定義されることが多いようだ．

そのあとで "nステップの簡約" を定義する．
具体的には

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_CONCLUSION
/e_1/
▷
/e_1/
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
/e_1/
▷_1
/e_2/
#+END_PREMISE
#+BEGIN_PREMISE
/e_2/
▷
/e_3/
#+END_PREMISE
#+BEGIN_CONCLUSION
/e_1/
▷
/e_3/
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

という具合にである．

また以上の定義から *許容規則* (/admissible rule/, メタ定理) として
▷
が推移的であること，すなわち

#+BEGIN_CENTER
#+BEGIN_INFER
#+BEGIN_PREMISE
/e_1/
▷
/e_2/
#+END_PREMISE
#+BEGIN_PREMISE
/e_2/
▷
/e_3/
#+END_PREMISE
#+BEGIN_CONCLUSION
/e_1/
▷
/e_3/
#+END_CONCLUSION
#+END_INFER
#+END_CENTER

が証明できる．注意しておくべきことは，
*派生規則* (/derivable rule/) ではないということ，
つまり以上の定義をただ単純に組みあわせただけでは証明できないということである．
これを証明するには，ちょっとテクニカルなこと(推論図の長さに関する帰納法,
いわば AST をとって AST を返すメタプログラミング)をする必要があるが，
難しくはない．

なおこれまでは意図的に無視して進めてきたが本来はα変換についてもちゃんとやらなければならない．
α変換についてはちゃんと意味論に組みこんできっちり議論するひとと
いつでもα変形してよいみたいな暗黙のルールを定めるひとがいる．
個人的には後者のほうが議論の見通しがよくなる気がするので好み．

* その他定理など

もちろん，意味論を定義してはい終わり，というわけにはなかなかならない．
意味論を定義したうえで，その意味論に関する性質を証明したりすることが重要になってくる．

なにを証明すればよいか，というのは体系によるのでなんともいえないのだが，
たとえば強正規化性（停止性）が成りたつよね，
あるいは逆に成りたたないことを示したりその理由とか考察するのが大事なのである．
（なおこういう視点で見ると単純型つきラムダ計算は化け物じみた性質をもっている）

型なしラムダ計算においては強正規化性は成りたたないので，
合流性定理 (Church-Rosser 性) が重要な定理として紹介されることが多い．

合流性というのは "どんな順番で簡約しても同じ結果になる" という性質で，
形式的には

#+BEGIN_CENTER
/e_1/ ▷ /e_2/ かつ /e_1/ ▷ /e_3/ ならば，
/e_2/ ▷ /e_4/ かつ /e_3/ ▷ /e_4/ となるような /e_4/ が存在する．
#+END_CENTER

と表される． (どこが形式的だ!! ∀ とか ∃ とか使って表さんかい!!
というのは勘弁して)

** 合流性の証明

合流性の証明には *並行簡約* (/Parallel reduction/) というものを使うとよいらしい．
このへんは正直理解できてないので勉強中．
どうにも並行簡約を使わずとも証明はできるものの，
並行簡約を使ったほうが証明が楽なようである．
正直，まだまだ勉強することが多い……．

* References

- 古森雄一, 小野寛晰. 『現代数理論理学序説』 2010.
- J. Roger Hindley, Jonathan P. Seldin.
  Lambda-Calculus and Combinators: An Introduction. 2008.
