<!DOCTYPE html>

<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/etc/site/style.css">
  <title>bydriv.github.io</title>
  <meta property="og:url" content="https://bydriv.github.io/blog/2021-03-07/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="bydriv.github.io" />
  <meta property="og:description" content="行列演算ライブラリを実装してみる" />
  <meta property="og:site_name" content="bydriv.github.io" />
  <meta property="og:image" content="https://bydriv.github.io/etc/site/thumbnail.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <script type="text/javascript" src="/etc/site/kt.js"></script>
</head>

<div class="navigation"><!--
--><div class="left"><!--
--><a class="section" href="/">&#x221A;</a><!--
--><a class="section" href="/blog">&#x1F4DD;</a><!--
--><a class="section" href="/illustration">&#x1F3A8;</a><!--
--><a class="section" href="/photo">&#x1F4F7;</a><!--
--><a class="section" href="/literature">&#x1F516;</a><!--
--><a class="section" href="/world">&#x1F4BD;</a><!--
--><a class="section" href="/comic">&#x1F4AD;</a><!--
--><a class="section" href="/vr">&#x1F9E9;</a><!--
--><a class="section" href="/misc">&#x1F4C1;</a><!--
--></div>&nbsp;<!--
--><div class="right"><!--
--><a class="holoio section" href="#holoio">&#x22EF;</a><!--
--></div><!--
--></div><!--
--><div id="holoio">
<div class="navigation"><!--
--><div class="left"><!--
-->&nbsp;</div>&nbsp;<!--
--><div class="right"><!--
--><a class="section" href="#">&#x2573;</a><!--
--></div><!--
--></div>

<div class="kt-month-calendar" data-today="true"></div>
</div>

<article>
<h1 id="行列演算ライブラリを実装してみる">行列演算ライブラリを実装してみる</h1>
<p>いろいろあって行列を真剣に頑張りたくなったので実装してみています。</p>
<h2 id="動機">動機</h2>
<p>正方行列を対角化して爆速なアルゴリズムを実装したい（？）</p>
<h2 id="今回の目標">今回の目標</h2>
<p>正方行列を対角化するアルゴリズムを (とりあえず CPU で) 動くところまでを目指します。行列演算ということで GPGPU でいろいろ頑張ることもできるかもしれませんが、ひとまず。</p>
<h2 id="数学的な準備">数学的な準備</h2>
<p>今回実装するのに使う主な数学を軽く説明します。</p>
<h3 id="可換環">可換環</h3>
<p>スカラーの操作に使います。乗法と加法が定義されている体系です。</p>
<p><em>集合と演算の存在</em>:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>∈</mo><mrow></mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">a,b,c,\cdots{}\in{}R</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mo>:</mo><mi>R</mi><mo>×</mo><mrow></mrow><mi>R</mi><mo accent="false">→</mo><mrow></mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">+:R\times{}R\rightarrow{}R</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo><mrow></mrow><mo>:</mo><mi>R</mi><mo>×</mo><mrow></mrow><mi>R</mi><mo accent="false">→</mo><mrow></mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">\times{}:R\times{}R\rightarrow{}R</annotation></semantics></math></li>
</ul>
<p><em>加法</em>:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a+b=b+a</annotation></semantics></math> (交換律)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(a+b\right)+c=a+\left(b+c\right)</annotation></semantics></math> (結合律)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo>+</mo><mi>a</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a+0=0+a=a</annotation></semantics></math> (単位元の存在)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a+\left(\text{-}a\right)=\left(\text{-}a\right)+a=0</annotation></semantics></math> (逆元の存在)</li>
</ul>
<p><em>乗法</em>:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo>=</mo><mi>b</mi><mo>×</mo><mrow></mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a\times{}b=b\times{}a</annotation></semantics></math> (交換律)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow></mrow><mi>c</mi><mo>=</mo><mi>a</mi><mo>×</mo><mrow></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>×</mo><mrow></mrow><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(a\times{}b\right)\times{}c=a\times{}\left(b\times{}c\right)</annotation></semantics></math> (結合律)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mn>1</mn><mo>=</mo><mn>1</mn><mo>×</mo><mrow></mrow><mi>a</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a\times{}1=1\times{}a=a</annotation></semantics></math> (単位元の存在)</li>
</ul>
<p><em>分配法則</em>:</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">a\times{}\left(b+c\right)=\left(a\times{}b\right)+\left(a\times{}c\right)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow></mrow><mi>c</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>×</mo><mrow></mrow><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(a+b\right)\times{}c=\left(a\times{}c\right)+\left(b\times{}c\right)</annotation></semantics></math></li>
</ul>
<h3 id="可換体">可換体</h3>
<p>可換環に加えて乗法逆元が存在します。</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><msubsup><mi>a</mi><mrow></mrow><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msubsup><mo>≠</mo><mrow></mrow><mn>0</mn><mo accent="false">⇒</mo><mrow></mrow><mi>a</mi><mo>×</mo><mrow></mrow><msubsup><mi>a</mi><mrow></mrow><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msubsup><mo>=</mo><msubsup><mi>a</mi><mrow></mrow><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msubsup><mo>×</mo><mrow></mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a,a_{}^{\text{-}1}\neq{}0\Rightarrow{}a\times{}a_{}^{\text{-}1}=a_{}^{\text{-}1}\times{}a=1</annotation></semantics></math> (逆元の存在)</li>
</ul>
<h3 id="ベクトル">ベクトル</h3>
<p>ベクトルは</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{v}=\left(a_1^{},a_2^{},\cdots{},a_n^{}\right)</annotation></semantics></math></p>
<p>というように <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> 個のなにかを並べたものです。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> をベクトルの次元と言います。</p>
<p>今回は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">a_1^{},a_2^{},\cdots{},a_n^{}\in{}R</annotation></semantics></math> を上述の可換環・可換体の集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math> の要素とします。</p>
<h3 id="ベクトルの内積">ベクトルの内積</h3>
<p>同じ次元のベクトルの内積は</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>b</mi><mi>n</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo>+</mo><mo>⋯</mo><mrow></mrow><mo>+</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><msubsup><mi>b</mi><mi>n</mi><mrow></mrow></msubsup></mrow><annotation encoding="application/x-tex">\vec{v}\vec{u}=\left(a_1^{},a_2^{},\cdots{},a_n^{}\right)\left(b_1^{},b_2^{},\cdots{},b_n^{}\right)=a_1^{}b_1^{}+a_2^{}b_2^{}+\cdots{}+a_n^{}b_n^{}</annotation></semantics></math></p>
<p>と定義されます。</p>
<h3 id="行列">行列</h3>
<p>行列は</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>11</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>12</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>21</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>22</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>m</mi><mn>2</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>m</mi><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A=\left(\begin{array}{cccc}a_{11}^{}&amp;a_{12}^{}&amp;\cdots{}&amp;a_{1n}^{}\\a_{21}^{}&amp;a_{22}^{}&amp;\cdots{}&amp;a_{2n}^{}\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\a_{m1}^{}&amp;a_{m2}^{}&amp;\cdots{}&amp;a_{mn}^{}\end{array}\right)</annotation></semantics></math></p>
<p>というように <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mrow></mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times{}m</annotation></semantics></math> 個のなにかを矩形に並べたものです。このような行列を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(m,n\right)</annotation></semantics></math> 行列などと言います (多くのプログラミング言語やライブラリとは座標系が異なりがちなことに注意)。</p>
<p>ここで並べたものを行列の成分と言います。行列の成分は数とは限りません。今回は上述の可換環や可換体になるなにかを成分とします。</p>
<p>行列のうち横並びの部分を行、縦並びの部分を列と呼びます。行や列をベクトルと見る場合</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mi>i</mi><mrow></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mrow><mi>i</mi><mn>2</mn></mrow><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{v}_i^{}=\left(a_{i1}^{},a_{i2}^{},\cdots{},a_{in}^{}\right)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mi>j</mi><mrow></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mrow><mn>1</mn><mi>j</mi></mrow><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mrow><mn>2</mn><mi>j</mi></mrow><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mrow><mi>m</mi><mi>j</mi></mrow><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{u}_j^{}=\left(a_{1j}^{},a_{2j}^{},\cdots{},a_{mj}^{}\right)</annotation></semantics></math></li>
</ul>
<p>などと置いて</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>1</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>2</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mi>m</mi><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A=\left(\begin{array}{c}\vec{v}_1^{}\\\vec{v}_2^{}\\\vdots{}\\\vec{v}_m^{}\end{array}\right)</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>1</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>2</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mi>n</mi><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">B=\left(\begin{array}{cccc}\vec{u}_1^{}&amp;\vec{u}_2^{}&amp;\cdots{}&amp;\vec{u}_n^{}\end{array}\right)</annotation></semantics></math></p>
<p>と行列を表現する場合もあります。行列には縦と横の区別がありますがベクトルにはありません。</p>
<h3 id="行列の積">行列の積</h3>
<p>行列の積はベクトルの内積で定義されます。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>1</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>2</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mi>m</mi><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>1</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>2</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mi>n</mi><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>1</mn></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>1</mn></msub></mtd><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>1</mn></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>2</mn></msub></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>1</mn></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>2</mn></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>1</mn></msub></mtd><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>2</mn></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>2</mn></msub></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mn>2</mn></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mi>n</mi></msub></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mi>m</mi></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>1</mn></msub></mtd><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mi>m</mi></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mn>2</mn></msub></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msub><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mi>m</mi></msub><msub><mover><mi>u</mi><mo accent="true">⃗</mo></mover><mi>n</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">AB=\left(\begin{array}{c}\vec{v}_1^{}\\\vec{v}_2^{}\\\vdots{}\\\vec{v}_m^{}\end{array}\right)\left(\begin{array}{cccc}\vec{u}_1^{}&amp;\vec{u}_2^{}&amp;\cdots{}&amp;\vec{u}_n^{}\end{array}\right)=\left(\begin{array}{cccc}\vec{v}_1\vec{u}_1&amp;\vec{v}_1\vec{u}_2&amp;\cdots{}&amp;\vec{v}_1\vec{u}_n\\\vec{v}_2\vec{u}_1&amp;\vec{v}_2\vec{u}_2&amp;\cdots{}&amp;\vec{v}_2\vec{u}_n\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\\vec{v}_m\vec{u}_1&amp;\vec{v}_m\vec{u}_2&amp;\cdots{}&amp;\vec{v}_m\vec{u}_n\\\end{array}\right)</annotation></semantics></math></p>
<p>ここで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(m,k\right)</annotation></semantics></math> 行列かつ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(k,n\right)</annotation></semantics></math> 行列でなければなりません。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> は同じであれば具体的な数は問いません。</p>
<h3 id="小行列">小行列</h3>
<p>行列から特定の行や列を取りのぞいて得られる行列を小行列と言います。</p>
<h3 id="正方行列">正方行列</h3>
<p>行列のうち <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n=m</annotation></semantics></math> となるようなものを <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> 次元正方行列と言います。</p>
<h3 id="行列式">行列式</h3>
<p>正方行列に対して行列式 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">det\left(A\right)</annotation></semantics></math> は次のように帰納的に定義されます。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>a</mi><mn>11</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>a</mi><mn>11</mn></msub></mrow><annotation encoding="application/x-tex">det\left(a_{11}\right)=a_{11}</annotation></semantics></math></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>11</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>12</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>21</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>22</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mn>1</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mn>2</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mi>a</mi><mn>11</mn><mrow></mrow></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>22</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>23</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>32</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>33</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>3</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mn>2</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mn>3</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msubsup><mi>a</mi><mn>21</mn><mrow></mrow></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>12</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>13</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>32</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>33</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>3</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mn>2</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mn>3</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mi>n</mi><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mo>⋯</mo><mo>+</mo><msubsup><mi>a</mi><mrow><mi>n</mi><mn>1</mn></mrow><mrow></mrow></msubsup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>12</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>13</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mn>22</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mn>23</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mn>3</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>a</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">det\left(\begin{array}{cccc}a_{11}^{}&amp;a_{12}^{}&amp;\cdots{}&amp;a_{1n}^{}\\a_{21}^{}&amp;a_{22}^{}&amp;\cdots{}&amp;a_{2n}^{}\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\a_{n1}^{}&amp;a_{n2}^{}&amp;\cdots{}&amp;a_{nn}^{}\end{array}\right)=a_{11}^{}\left(\text{-}1\right)^\left(1+1\right)det\left(\begin{array}{cccc}a_{22}^{}&amp;a_{23}^{}&amp;\cdots{}&amp;a_{2n}^{}\\a_{32}^{}&amp;a_{33}^{}&amp;\cdots{}&amp;a_{3n}^{}\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\a_{n2}^{}&amp;a_{n3}^{}&amp;\cdots{}&amp;a_{nn}^{}\end{array}\right)+a_{21}^{}\left(\text{-}1\right)^\left(2+1\right)det\left(\begin{array}{cccc}a_{12}^{}&amp;a_{13}^{}&amp;\cdots{}&amp;a_{1n}^{}\\a_{32}^{}&amp;a_{33}^{}&amp;\cdots{}&amp;a_{3n}^{}\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\a_{n2}^{}&amp;a_{n3}^{}&amp;\cdots{}&amp;a_{nn}^{}\end{array}\right)+\cdots+a_{n1}^{}\left(\text{-}1\right)^\left(n+1\right)det\left(\begin{array}{cccc}a_{12}^{}&amp;a_{13}^{}&amp;\cdots{}&amp;a_{1n}^{}\\a_{22}^{}&amp;a_{23}^{}&amp;\cdots{}&amp;a_{2n}^{}\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\a_{\left(n-1\right)2}^{}&amp;a_{\left(n-1\right)3}^{}&amp;\cdots{}&amp;a_{\left(n-1\right)n}^{}\end{array}\right)</annotation></semantics></math></p>
<p>後者の定義で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow></mrow></msubsup><annotation encoding="application/x-tex">a_{ij}^{}</annotation></semantics></math> の <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i+j</annotation></semantics></math> の偶奇によって <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">\left(\text{-}1\right)^\left(i+j\right)</annotation></semantics></math> 符号が変化し、また最初の列と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> 行目を取りのぞいた小行列の行列式を再帰的に求めます。</p>
<p>(計算効率などの都合で行列式の定義にはいろいろな流派があります。これは余因子展開と呼ばれるものです)。</p>
<h3 id="余因子">余因子</h3>
<p>正方行列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> のおのおのの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math> に対して 余因子 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>M</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><mrow></mrow></msubsup><annotation encoding="application/x-tex">M_{i,j}^{}</annotation></semantics></math> とは、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> から <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> 行と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> 列を取りのぞいて得られる小行列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> の行列式に偶奇の符号をかけたもの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>M</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><mrow></mrow></msubsup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">-</mtext><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>+</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow></msup><mi>d</mi><mi>e</mi><mi>t</mi><mo stretchy="false" form="prefix">(</mo><mi>B</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">M_{i,j}^{}=\left(\text{-}1\right)^\left(i+j\right)det(B)</annotation></semantics></math> と定義されます。</p>
<p>（今回は行列式の定義の都合で行列式の定義内に余因子に似た部分式が出現していますが、行列式自体はほかの定義もできます）</p>
<h3 id="余因子行列">余因子行列</h3>
<p>正方行列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> のおのおのの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math> に対して 余因子 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>M</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><mrow></mrow></msubsup><annotation encoding="application/x-tex">M_{i,j}^{}</annotation></semantics></math> を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(i,j\right)</annotation></semantics></math> 成分とする行列の転置行列を余因子行列と言い <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">adj\left(A\right)</annotation></semantics></math> と表します。</p>
<h3 id="単位行列">単位行列</h3>
<p>正方行列のうち (同じ次元の) 任意の正方行列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> について</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>I</mi><mo>=</mo><mi>I</mi><mi>A</mi><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">AI=IA=A</annotation></semantics></math></p>
<p>となるような正方行列 (正方行列の積の単位元) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> を単位行列と言います。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> は</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋮</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋱</mo><mrow></mrow></mtd><mtd><mo>⋮</mo><mrow></mrow></mtd></mtr><mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">I=\left(\begin{array}{ccc}1&amp;0&amp;\cdots{}&amp;0\\0&amp;1&amp;\cdots{}&amp;0\\\vdots{}&amp;\vdots{}&amp;\ddots{}&amp;\vdots{}\\0&amp;0&amp;\cdots{}&amp;1\end{array}\right)</annotation></semantics></math></p>
<p>というように対角線部分が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>, それ以外が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math> であるような正方行列として表せます。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mn>11</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mn>22</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mrow><mi>n</mi><mi>n</mi></mrow><mrow></mrow></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_{11}^{},a_{22}^{},\cdots{},a_{nn}^{}=1</annotation></semantics></math> というように添え字が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i=j</annotation></semantics></math> となるような部分を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math> で埋めたものです。</p>
<h3 id="正則行列">正則行列</h3>
<p>正方行列のうち行列の積の逆元が存在するものを正則行列と言います。つまり</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><mi>A</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">AA^{\text{-}1}=A^{\text{-}1}A=I</annotation></semantics></math></p>
<p>となるような <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">A^{\text{-}1}</annotation></semantics></math> が存在するとき、かつそのときにかぎり、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> は正則行列です。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">A^{\text{-}1}</annotation></semantics></math> が存在しない正方行列はたくさんあります。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> が正則行列であるのは、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mrow></mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">det\left(A\right)\neq{}0</annotation></semantics></math> であるとき、かつそのときにかぎります。ゆえに <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mrow></mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">det\left(A\right)\neq{}0</annotation></semantics></math> か否かで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> が正則行列か否か (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">A^{\text{-}1}</annotation></semantics></math> が存在するか否か) を判定することができます。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> から <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">A^{\text{-}1}</annotation></semantics></math> を計算で求めるには乗法逆元が必要です。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">det\left(A\right)</annotation></semantics></math> の乗法逆元 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">det\left(A\right)^{\text{-}1}</annotation></semantics></math> で表せば</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><mo>=</mo><mi>d</mi><mi>e</mi><mi>t</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><mi>a</mi><mi>d</mi><mi>j</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A^{\text{-}1}=det\left(A\right)^{\text{-}1}adj\left(A\right)</annotation></semantics></math></p>
<p>で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>A</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">A^{\text{-}1}</annotation></semantics></math> を計算（プログラム）で求めることができます。</p>
<h3 id="正方行列の対角化">正方行列の対角化</h3>
<p>正方行列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> を対角化するには、正則行列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> を <em>適当に</em> 選んで</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>=</mo><msup><mi>P</mi><mrow><mtext mathvariant="normal">-</mtext><mn>1</mn></mrow></msup><mi>A</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">D=P^{\text{-}1}AP</annotation></semantics></math></p>
<p>とします。</p>
<p>この <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> を <em>適当に</em> 選ぶには固有値に関する方程式を解く必要があります。</p>
<p>ここまでをプログラムとして実装するのが今回の目標ですが、固有値と固有ベクトルについても軽く触れておきます。</p>
<h3 id="固有値と固有ベクトル">固有値と固有ベクトル</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> の固有値 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mrow></mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">\lambda\in{}R</annotation></semantics></math> と固有ベクトル <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>v</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math> とは</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mover><mi>v</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mi>λ</mi><mover><mi>v</mi><mo accent="true">⃗</mo></mover></mrow><annotation encoding="application/x-tex">A\vec{v}=\lambda\vec{v}</annotation></semantics></math></p>
<p>の等式が成り立つものを言います。</p>
<h3 id="固有方程式">固有方程式</h3>
<p>ある <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>∈</mo><mrow></mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">\lambda\in{}R</annotation></semantics></math> が与えられたとき、それが <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> の固有値かを判定するには</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>−</mo><mi>λ</mi><mrow></mrow><mi>I</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">det\left(A-\lambda{}I\right)=0</annotation></semantics></math></p>
<p>を計算します。この式は固有方程式や特性方程式と呼ばれます。</p>
<h2 id="実装">実装</h2>
<p>以上を実装してみます。</p>
<p>今回はあくまで行列について考えますが、前準備として環と体について軽く触れておきます。</p>
<p>まず環というのは簡単に言えば足し算と掛け算 (と引き算) ができる体系です。体というのはそれに加えて割り算ができます。</p>
<p>プログラムとして実装するとき、行列の成分は float や double で決め打ちでもよいのですが、ほかの型も使えるようになっているとあとあと都合がよいのでそうしてみます。</p>
<p>というわけでまず環 (ring) と体 (field) を定義します。</p>
<h3 id="signature-ring">signature RING</h3>
<pre><code>(* signature RING                                                             *)
(*                                                                            *)
(* ADDITIVE LAWS                                                              *)
(*                                                                            *)
(*   (a + b) + c = a + (b + c)                                                *)
(*   a + b       = b + a                                                      *)
(*   zero + a    = a                                                          *)
(*   a + zero    = a                                                          *)
(*   a + ~a      = zero                                                       *)
(*                                                                            *)
(* MULTIPLICATIVE LAWS                                                        *)
(*                                                                            *)
(*   (a * b) * c = a * (b * c)                                                *)
(*   one * a     = a                                                          *)
(*   a * one     = a                                                          *)
(*                                                                            *)
(* DISTRIBUTIVE LAWS                                                          *)
(*                                                                            *)
(*   a * (b + c) = a * b + a * c                                              *)
(*   (a + b) * c = a * c + b * c                                              *)

signature RING = sig
  type t
  val zero : t
  val one : t
  val + : t * t -&gt; t
  val * : t * t -&gt; t
  val ~ : t -&gt; t
end</code></pre>
<h3 id="signature-field">signature FIELD</h3>
<pre><code>signature FIELD = sig
  include RING
  val inverse : t -&gt; t option
end</code></pre>
<p>ML の型システム (だけでなくおよそほとんどの言語の型システム) では多くの公理を表現できませんのでコメントに記述しています。</p>
<p>ちなみに <code>a : t</code> かつ <code>b : t</code> ならば <code>a + b : t</code> という性質も公理と考えることがありますがこれは型システムで表現できますので省略しています。</p>
<p>(なおこの性質がないと <code>a + b + c</code> とどんどん再帰的に組み合わせていけないので、いろいろ組み合わせてなにかをつくるために重要な性質)</p>
<h2 id="signature-matrix-and-signature-field_matrix">signature MATRIX and signature FIELD_MATRIX</h2>
<p>環のみを仮定した <code>MATRIX</code> と体 (乗法逆元) を仮定しないと実装できない <code>FIELD_MATRIX</code> を分けてみます。</p>
<h3 id="signature-matrix">signature MATRIX</h3>
<pre><code>signature MATRIX = sig
  exception Dimension

  type scalar
  type matrix

(* PRIMITIVE OPERATIONS                                                       *)

  val new : int * int * (int * int -&gt; scalar) -&gt; matrix

  val width : matrix -&gt; int
  val height : matrix -&gt; int

  val element : int * int * matrix -&gt; scalar option
  val row : int * matrix -&gt; scalar vector option
  val column : int * matrix -&gt; scalar vector option

(* BASIC OPERATIONS                                                           *)
(*                                                                            *)
(*   A + B raises Dimension if width A &lt;&gt; width B or height A &lt;&gt; height B.    *)
(*   A - B raises Dimension if width A &lt;&gt; width B or height A &lt;&gt; height B.    *)
(*   A * B raises Dimension if width A &lt;&gt; height B.                           *)

  val submatrix : int * int * matrix -&gt; matrix
  val transpose : matrix -&gt; matrix
  val scale : scalar * matrix -&gt; matrix

  val + : matrix * matrix -&gt; matrix
  val - : matrix * matrix -&gt; matrix
  val * : matrix * matrix -&gt; matrix

(* SQUARE MATRIX OPERATIONS                                                   *)
(*                                                                            *)
(*   eigenequation(a, A) returns R.zero if a is an eigenvalue of A.           *)
(*                                                                            *)
(*   determinant A raises Dimension if not (isSquareMatrix A).                *)
(*   adjugate A raises Dimension if not (isSquareMatrix A).                   *)
(*   eigenequation(a, A) raises Dimension if not (isSquareMatrix A).          *)

  val isSquareMatrix : matrix -&gt; bool

  val identityMatrix : int -&gt; matrix

  val determinant : matrix -&gt; scalar
  val adjugate : matrix -&gt; matrix
  val eigenequation : scalar * matrix -&gt; scalar

(* PROCEDURAL OPERATIONS                                                      *)

  val appiRow : matrix * (int * scalar vector -&gt; unit) -&gt; unit
  val appiCol : matrix * (int * scalar vector -&gt; unit) -&gt; unit
  val appRow : matrix * (scalar vector -&gt; unit) -&gt; unit
  val appCol : matrix * (scalar vector -&gt; unit) -&gt; unit

(* CONSTRUCTORS                                                               *)
(*                                                                            *)
(* fromRows rows raises Dimension if length of some rows is different.        *)

  val fromRows : scalar list list -&gt; matrix
end</code></pre>
<h3 id="signature-field_matrix">signature FIELD_MATRIX</h3>
<pre><code>signature FIELD_MATRIX = sig
  include MATRIX

(* REGULAR MATRIX OPERATIONS                                                  *)
(*                                                                            *)
(*   inverse A raises Dimension if not (isRegularMatrix A).                   *)

  val isRegularMatrix : matrix -&gt; bool

  val inverse : matrix -&gt; matrix
end</code></pre>
<h3 id="functor-matrix">functor Matrix</h3>
<p>公理系を仮定したコードは <code>functor</code> で書くとすっきり書けたりします (型クラスや trait でもいいけど)</p>
<pre><code>functor Matrix(R : RING) :&gt; MATRIX where type scalar = R.t = struct
  exception Dimension

  type scalar = R.t

  abstype matrix = MATRIX of {
    width : int,
    height : int,
    elements : scalar vector
  } with
    fun new(width, height, f) = MATRIX {
      width =
        width,
      height =
        height,
      elements =
        Vector.tabulate(width * height, fn i =&gt; let
          val (x, y) = (i mod width, i div width)
        in
          f(x, y)
        end)
    }

    fun width(MATRIX {width, ...}) =
      width

    fun height(MATRIX {height, ...}) =
      height

    fun element(x, y, MATRIX {width, height, elements}) = let
      val i = y * width + x
    in
      if not (0 &lt;= i andalso i &lt; width * height) then
        NONE
      else
        SOME(Vector.sub(elements, i))
    end

    fun column(x, MATRIX {width, height, elements}) =
      if not (0 &lt;= x andalso x &lt; width) then
        NONE
      else let
        val v = Vector.tabulate(height, fn i =&gt;
          Vector.sub(elements, i * width + x))
      in
        SOME v
      end

    fun row(y, MATRIX {width, height, elements}) =
      if not (0 &lt;= y andalso y &lt; height) then
        NONE
      else let
        val v = Vector.tabulate(width, fn i =&gt;
          Vector.sub(elements, y * width + i))
      in
        SOME v
      end
  end

  local
    fun sub(x, y, A) =
      case element(x, y, A) of
        NONE =&gt;
          raise Subscript
      | SOME a =&gt;
          a

    fun subColumn(x, A) =
      case column(x, A) of
        NONE =&gt;
          raise Subscript
      | SOME v =&gt;
          v

    fun subRow(y, A) =
      case row(y, A) of
        NONE =&gt;
          raise Subscript
      | SOME v =&gt;
          v
  in
    fun submatrix(x, y, A) =
      if width A = 0 orelse height A = 0 then
        A
      else if not (0 &lt;= x andalso x &lt; width A) then
        A
      else if not (0 &lt;= y andalso y &lt; height A) then
        A
      else
        new(width A - 1, height A - 1, fn (i, j) =&gt;
          if i &lt; x andalso j &lt; y then
            sub(i, j, A)
          else if i &lt; x then
            sub(i, j + 1, A)
          else if j &lt; y then
            sub(i + 1, j, A)
          else
            sub(i + 1, j + 1, A))

    fun transpose A =
      new(height A, width A, fn (i, j) =&gt; sub(j, i, A))

    fun scale(a, A) =
      new(width A, height A, fn (i, j) =&gt; R.*(a, sub(i, j, A)))

    fun A + B =
      if not (width A = width B andalso height A = height B) then
        raise Dimension
      else let
        val n = width A (* = width B *)
        val m = height A (* = height B *)
      in
        new(n, m, fn (i, j) =&gt; R.+(sub(i, j, A), sub(i, j, B)))
      end

    fun A - B =
      if not (width A = width B andalso height A = height B) then
        raise Dimension
      else let
        val n = width A (* = width B *)
        val m = height A (* = height B *)
      in
        new(n, m, fn (i, j) =&gt; R.+(sub(i, j, A), R.~(sub(i, j, B))))
      end

    fun A * B =
      if not (width A = height B) then
        raise Dimension
      else let
        val n = width A (* = height B *)
      in
        new(width B, height A, fn (i, j) =&gt; let
          val (v, u) = (subRow(j, A), subColumn(i, B))
          val l = List.tabulate(n, fn k =&gt;
            R.*(Vector.sub(v, k), Vector.sub(u, k)))
        in
          List.foldr R.+ R.zero l
        end)
      end

    fun isSquareMatrix A =
      width A = height A

    fun identityMatrix n =
      new(n, n, fn (i, j) =&gt; if i = j then R.one else R.zero)

    fun determinant A =
      if not (isSquareMatrix A) then
        raise Dimension
      else let
        val n = width A (* = height A *)
      in
        if n = 0 then
          R.zero
        else if n = 1 then
          sub(0, 0, A)
        else let
          val i = ref 0
          val a = ref R.zero
        in
          while !i &lt; n do (
            if !i mod 2 = 0 then
              a := R.+(!a, R.*(sub(0, !i, A), determinant(submatrix(0, !i, A))))
            else
              a := R.+(!a, R.~(R.*(sub(0, !i, A), determinant(submatrix(0, !i, A)))));
            i := Int.+(!i, 1));
          !a
        end
      end

    fun adjugate A =
      if not (isSquareMatrix A) then
        raise Dimension
      else
        new(height A, width A, fn (i, j) =&gt;
          if Int.+(i, j) mod 2 = 0 then
            determinant(submatrix(j, i, A))
          else
            R.~(determinant(submatrix(j, i, A))))

    fun eigenequation(a, A) =
      if not (isSquareMatrix A) then
        raise Dimension
      else let
        val n = width A (* = height A *)
        val I = identityMatrix n
      in
        determinant(A - scale(a, I))
      end

    fun appiRow(A, f) = let
      val i = ref 0
    in
      while !i &lt; height A do (
        f(!i, subRow(!i, A));
        i := Int.+(!i, 1))
    end

    fun appiCol(A, f) = let
      val i = ref 0
    in
      while !i &lt; width A do (
        f(!i, subColumn(!i, A));
        i := Int.+(!i, 1))
    end

    fun appRow(A, f) =
      appiRow(A, fn (_, v) =&gt; f v)

    fun appCol(A, f) =
      appiCol(A, fn (_, v) =&gt; f v)

    fun fromRows rows =
      case rows of
        nil =&gt;
          new(0, 0, fn _ =&gt; R.zero)
      | row :: _ =&gt; let
          val width = List.length row
          val height = List.length rows
          val rows = Vector.fromList (List.map Vector.fromList rows)
        in
          if Vector.exists (fn row =&gt; Vector.length row &lt;&gt; width) rows then
            raise Dimension
          else
            new(width, height, fn (i, j) =&gt;
              Vector.sub(Vector.sub(rows, j), i))
        end
  end
end</code></pre>
<h3 id="functor-fieldmatrix">functor FieldMatrix</h3>
<p>乗法逆元が必要なコード。</p>
<pre><code>functor FieldMatrix(F : FIELD) :&gt; FIELD_MATRIX where type scalar = F.t = struct
  local structure M = Matrix(F) in
    open M

    fun isRegularMatrix A =
      if not (isSquareMatrix A) then
        false
      else
        Option.isSome (F.inverse (determinant A))

    fun inverse A =
      case F.inverse (determinant A) of
        NONE =&gt;
          raise Dimension
      | SOME a =&gt;
          scale (a, adjugate A)
  end
end</code></pre>
<h3 id="instances">instances</h3>
<p>最後に instance を定義</p>
<pre><code>structure IntRing : RING = struct
  type t = int
  val zero = 0
  val one = 1
  val op + = Int.+
  val op * = Int.*
  val ~ = Int.~
end

structure RealField : FIELD = struct
  type t = real
  val zero = 0.0
  val one = 1.0
  val op + = Real.+
  val op * = Real.*
  val ~ = Real.~

  fun inverse q =
    if Real.==(q, 0.0) then
      NONE
    else
      SOME (1.0 / q)
end

structure IntMatrix = Matrix(IntRing)
structure RealMatrix = FieldMatrix(RealField)</code></pre>
<h2 id="動かしてみる">動かしてみる</h2>
<p>実際に対角化できる正方行列を対角化してみる。</p>
<pre><code>fun printMatrix A =
  RealMatrix.appRow(A, fn row =&gt;
    let
      val s =
        String.concatWith &quot;\t&quot;
          (Vector.foldr (op ::) nil (Vector.map Real.toString row)) ^ &quot;\n&quot;
    in
      print s
    end)

val () = let
  open RealMatrix

  val A = RealMatrix.fromRows [
    [1.0, 2.0, 0.0],
    [0.0, 3.0, 0.0],
    [2.0, ~4.0, 2.0]
  ]

  val P = RealMatrix.fromRows [
    [~1.0, 0.0, ~1.0],
    [~1.0, 0.0, 0.0],
    [2.0, 1.0, 2.0]
  ]

  val P&#39; = inverse P

  val hr = String.concat (List.tabulate(80, fn _ =&gt; &quot;=&quot;)) ^ &quot;\n&quot;
in
  print hr;
  print &quot;A =\n&quot;;
  print hr;
  printMatrix A;
  print hr;
  print &quot;P =\n&quot;;
  print hr;
  printMatrix P;
  print hr;
  print &quot;P^{-1}AP =\n&quot;;
  print hr;
  printMatrix (P&#39; * A * P);
  print hr
end</code></pre>
<p>するとこんな感じに動く。</p>
<pre><code>$ mlton examples/diagonalize.mlb
$ examples/diagonalize
================================================================================
A =
================================================================================
1       2       0
0       3       0
2       ~4      2
================================================================================
P =
================================================================================
~1      0       ~1
~1      0       0
2       1       2
================================================================================
P^{-1}AP =
================================================================================
3       0       0
0       2       0
0       0       1
================================================================================</code></pre>
<p>なんとなくよさそう！</p>
<h2 id="appendix-a.-full-code-listing">Appendix A. Full Code Listing</h2>
<ul>
<li><a href="/misc/matrix">Matrix</a></li>
</ul>
</article>
