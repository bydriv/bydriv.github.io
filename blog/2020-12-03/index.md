---
url: https://bydriv.github.io/blog/2020-12-03/
title: bydriv.github.io
description: "とりとめのない話 (閑話休題): 公理的設計、演繹的プログラミング、構文と意味の禅問答"
thumbnail: https://bydriv.github.io/etc/site/thumbnail.png
---

# とりとめのない話 (閑話休題): 公理的設計、演繹的プログラミング、構文と意味の禅問答

- *([とりとめのない話 (閑話休題): ソフトウェアの設計と開発の複雑性についての雑記](../2020-12-02) の続き)*

普段考えているとりとめのない話 (の言語化)。

今回は **演繹的プログラミング** (*deductive programming*), **公理的設計** (*axiomatic design*) について述べる。

*ここでは型理論をメタ理論としていることに注意。*

## 公理的設計

**公理** 𝔸, 𝕋<sub>1</sub>, 𝕋<sub>2</sub>, .., 𝕋<sub>n</sub>
を型とする。
𝒻<sub>1</sub>, 𝒻<sub>2</sub>, .., 𝒻<sub>n</sub> を関数とする。
𝓍<sub>1</sub>, 𝓍<sub>2</sub>, ..., 𝓍<sub>m</sub> を値とする。

- ⊢ 𝒻<sub>1</sub> : 𝔸 → 𝕋<sub>1</sub> かつ ⊢ 𝒻<sub>2</sub> : 𝔸 → 𝕋<sub>2</sub> かつ .. かつ ⊢ 𝒻<sub>n</sub> : 𝔸 → 𝕋<sub>n</sub>
- ⊢ 𝓍<sub>1</sub> : 𝔸 かつ ⊢ 𝓍<sub>2</sub> : 𝔸 かつ .. かつ ⊢ 𝓍<sub>m</sub> : 𝔸

を満たすとき、 ℳ =
(𝔸, {𝕋<sub>1</sub>, 𝕋<sub>2</sub>, .., 𝕋<sub>n</sub>},
{𝒻<sub>1</sub>, 𝒻<sub>2</sub>, .., 𝒻<sub>n</sub>},
{𝓍<sub>1</sub>, 𝓍<sub>2</sub>, ..., 𝓍<sub>m</sub>}) は **公理的** (*axiomatic*) であると言う。

*公理的であるような ℳ を考えられる設計を **公理的設計** (axiomatic design) と言う。
公理的設計で開発することを **演繹的開発** (deductive development) と言う。
とくにプログラムを公理的設計で開発することを **演繹的プログラミング** (deductive programming) と言う。*

ℳ を **公理系** (*axiomatic system*) と言い、
𝔸 を ℳ の **公理** (*axiom*) と言い、
𝕋<sub>1</sub>, 𝕋<sub>2</sub>, .., 𝕋<sub>n</sub> を ℳ の **定理** (*theorem*) と言う。

**定理** 𝕏<sub>1</sub>, 𝕏<sub>2</sub>, .., 𝕏<sub>m</sub> を型とする。

- α <: β, M : α ⊢ M : β
- α <: β, M : ∀a <: β. γ ⊢ M : [α/a]γ
- ⊢ 𝒻<sub>1</sub> : ∀a <: 𝔸. a → 𝕋<sub>1</sub> かつ ⊢ 𝒻<sub>2</sub> : ∀a <: 𝔸. a → 𝕋<sub>2</sub> かつ .. かつ ⊢ 𝒻<sub>n</sub> : ∀a <: 𝔸. a → 𝕋<sub>n</sub>
- ⊢ 𝓍<sub>1</sub> : 𝕏<sub>1</sub> かつ ⊢ 𝓍<sub>2</sub> : 𝕏<sub>2</sub> かつ .. かつ ⊢ 𝓍<sub>m</sub> : 𝕏<sub>m</sub>
- 𝕏<sub>1</sub> <: 𝔸 かつ 𝕏<sub>2</sub> <: 𝔸 かつ .. かつ 𝕏<sub>m</sub> <: 𝔸

ならば
(𝔸, {𝕋<sub>1</sub>, 𝕋<sub>2</sub>, .., 𝕋<sub>n</sub>},
{𝒻<sub>1</sub>, 𝒻<sub>2</sub>, .., 𝒻<sub>n</sub>},
{𝓍<sub>1</sub>, 𝓍<sub>2</sub>, ..., 𝓍<sub>m</sub>}) は
公理的である。

**定理** 𝕏<sub>1</sub>, 𝕏<sub>2</sub>, .., 𝕏<sub>m</sub> を型とする。

- α <: β, M : α ⊢ M as β : β
- α <: β, M : ∀a <: β. γ ⊢ M : [α/a]γ
- ⊢ 𝒻<sub>1</sub> : ∀a <: 𝔸. a → 𝕋<sub>1</sub> かつ ⊢ 𝒻<sub>2</sub> : ∀a <: 𝔸. a → 𝕋<sub>2</sub> かつ .. かつ ⊢ 𝒻<sub>n</sub> : ∀a <: 𝔸. a → 𝕋<sub>n</sub>
- ⊢ 𝓍<sub>1</sub> : 𝕏<sub>1</sub> かつ ⊢ 𝓍<sub>2</sub> : 𝕏<sub>2</sub> かつ .. かつ ⊢ 𝓍<sub>m</sub> : 𝕏<sub>m</sub>
- 𝕏<sub>1</sub> <: 𝔸 かつ 𝕏<sub>2</sub> <: 𝔸 かつ .. かつ 𝕏<sub>m</sub> <: 𝔸

ならば
(𝔸, {𝕋<sub>1</sub>, 𝕋<sub>2</sub>, .., 𝕋<sub>n</sub>},
{𝒻<sub>1</sub>, 𝒻<sub>2</sub>, .., 𝒻<sub>n</sub>},
{𝓍<sub>1</sub> as 𝔸, 𝓍<sub>2</sub> as 𝔸, .., 𝓍<sub>m</sub> as 𝔸}) は
公理的である。

### 公理的設計の 3 原則

1. **公理の自明性** (*triviality of axioms*) - 公理の構成がすくなくとも定理より容易なこと
2. **定理の非自明性** (*nontriviality of theorems*) - 定理の構成がすくなくとも公理より困難なこと
3. **実例の無限性** (*infiniteness of instances*) - 公理を満たす実例がすくなくとも可算無限個存在しうること

### 公理系の階層と合成可能性

ある公理系 ℳ の 定理 𝕋<sub>i</sub> が、ほかの公理系 𝒩 の公理 𝔸 であることがある。
このとき

- ℳ ⇒ 𝒩

と表し、 ℳ と 𝒩 とは **合成可能** (*composable*) であると言う。

𝒩 の関数は n 個、値は m 個ありその組み合わせは n * m 個ある。
これを ℳ で実装する場合、n * m 個の関数を実装することになる。
𝒩 であれば n + m 個の値と関数を実装すれば済む。

<!--
ℳ は究極的には CPU, OS, あるいはプログラミング言語というプラットフォームである。
そしてライブラリ、フレームワーク、ゲームエンジンといったプラットフォームが派生する。
この階層は木か、あるいはグラフになるだろう。

これは抽象化レイヤーを設計するということでもある。
そして公理というのはレイヤー同士を結合するインターフェースであり、
きちんと設計されなければならない。 **いいね？**
-->

## 公理的設計を実践する

<!--
*これは机上の空論ではない。むしろひどく現実主義的で泥臭い。
わたしは何度かこの方法を実践してうまくいったと思う。
ただ、言葉にして伝えようと思うとこういう理論っぽい語り口になってしまって、
わたしとしてもわりと職人気質なところもあり、
実際のところ実践的ではないのでは？　というのも、わかる。*
-->

### 具体的な実装方法: 辞書渡しスタイル

単相で関数が第二級な言語でもできる、とても汎用的なスタイル。
シンプルで簡単なので、わたしはとてもすき。

```
data A
data T
f :: A -> T
x :: A
```

### 具体的な実装方法: 型クラス

これは
`f : ∀a <: A. a → T`,
`x : X`,
`X <: A`
という関係とみなせる。

```
class A a
data T
data X; instance A X
f :: A a => a -> T
x :: X
```

### 具体的な実装方法: ファンクタ

OCaml の場合はモジュールレベルで公理的設計をする。

```
module type A = sig end
module type T = sig end
module F(X : A) : T = struct end
module X : A = struct end
```


### 公理的設計のベストプラクティス

**具体的な構造と一般的な操作を分離する。**
具体的な構造に対する具体的な操作は、常にアンチパターンだ。

### 抽象化レイヤーに関する考え方

抽象化レイヤーを設計することは複雑性を減らす。

公理は抽象化レイヤーとしてのインターフェースという意味でもある。
公理系は上のレイヤーとは公理において、下のレイヤーとは定理において連絡する。

ここにどういう公理を置くかは自由だが、基本的には、上のレイヤーの具体的な構造を
幅広く一般的に操作できるようにするのが基本だろう。ただし、すべての具体的な構造を
無理に同じ公理で説明するのもよくないだろう。

### トップダウン vs ボトムアップ

いつ抽象化するか？　ふたつ考えられる。

- トップダウンなやり方: 先に公理を定義して、すべてを演繹的に証明する
- ボトムアップなやり方: 先に定理を証明して、 **単一化** (*unification*) によって公理を仮説形成する

トップダウンっていうのは、普通は難しい。
ボトムアップは、悪くないと思う。操作を追加するときに、
常に単一化を意識して仮説形成しつつ開発する。

ボトムアップなやり方としてわたしが楽だと思うのは、
とりあえず最初はすべてを単相に書く。
そして必要なときだけ、多相にしたり公理を変えたりする。

リファクタリングするときはある程度全体を見て、
トップダウンに設計したほうがきれいになることは多い。

### 構文と意味の禅問答

抽象化とはなにか？　難しい。
型レベルの抽象化もあるし、値レベルでの抽象化もある。
ただ最近得た直観としては、 **構文** (*syntax*) と
**意味** (*semantics*) を分離するってことが、
抽象化ってことなんだと思う。

記号論理学を学ぶとき、この区別は徹底的に教わる。
普通は構文の意味について考えてしまう。なんの意味もない、単なる記号として見ることができない。

単なる記号として見ることができないと、いつも公理の意味について考えてしまって、混乱する。
この推論規則はどういう意味ですか、そう考えて混乱する。
ただある時点で、記号と意味を区別するという直観を得る。

そうするとああ、なんて簡単なことなんだろう。
これはただの記号で、その操作についてだけ考えればよくて、
意味なんて気にする必要はないんだと。そうすると、するすると頭に入ってくる。

ただこの直観を最近ソフトウェア開発において得たのは、ずいぶん最近のことだ。
もちろん **弱い力** と **強い力** を分離することが、
結局は開発するのを楽にするってことはずいぶん前からわかっていた。
弱い力は単純で簡単なデータで、強い力は複雑で難しい関数だ。
ただそれを抽象化という概念とどうむすびつけていいのか、わからなかった。

抽象化というのは、構文と意味を分離するってことだ。

たとえば、

```
f :: T -> U
g :: T -> U
```

という関数があったとしよう。 `f`, `g` は型も実装もまったく同じだ。
ではなぜ別々に実装されているのか？　それは **構文** は同じでも **意味** は違うからだ。
これはたしかに、筋が通る。

論理学の考え方では、構文が同じってことは、同じってことだ。
それは意味が同じってことじゃなくて、あまりにも抽象的なレイヤーなので、もはや意味なんて考える必要がないからだ。
ただその考え方をそのままソフトウェア開発に適用できないのは、構文が同じでも意味が違うってことは、実際あるからだ。
実際ある以上、ただちに同じだとは言えない。この `f` と `g` の意味について考えないといけない。

まず、 `f` と `g` を分けるメリットは、意味が違うからだ。
デメリットは、 `f`, `g` 両方をメンテしなくちゃいけないってことだ。
メンテする対象は少ないほうがいい。だからまとめたいものの、
意味について考えずにただ単にまとめるのは、筋が悪い。

`f` と `g` の意味について考えよう。
意味が違うっていうのは、 `f` の場合だけ挙動を変えたくなることもあるし、
`g` の場合だけ挙動を変えたくなることもある。こう言い表される。
ということは、なんらかの隠れた変数があるってことだ。

じゃあ仮に、 `f`, `g` の意味を `f'`, `g'` と表したとしよう。

```
data A
f' :: A
g' :: A
h :: A -> T -> U
```

これなら `f = h f'` かつ `g = h g'` であって、
実のところ意味を変数で表してしまえば、 `f`, `g` を意味で分ける意味はまったくなかったのだ。

じゃあ、具体的に `A` というのをどう定義するか？　仮に関数名が `f`, `g` の意味だったのだとすれば、
代数的データ型で定義できるかもしれない。

```
data A = F | G

f' :: A
f' = F

g' :: A
g' = G

h :: A -> T -> U
h F = f
h G = g
```

こうなる。

`f` と `g` の型が違う場合でも、
関数名を代数的データ型で定義して、しかも依存型を使えばいいので理論的には、
常に共通化は可能だろう (もちろん言語による)。

ただ、一般的にはその関数の意味というのは、関数名ではない。
これは明らかに間違った共通化だ。

ただ `h F` と書くのと `f` と書くのはまったく同じなので、
間違った共通化だからといってただ単に分けるというのも、やはり間違った分離の方法だ。
関数内で分岐するか人力で分岐して呼び分けるかって違いしかない。

逆説的ではあるけど、これは関数名で意味を表すってのは、基本的に悪手だってことでもある。
というよりも、それは意味で分けたつもりになっていて、実のところどういう意味で分けているのか、それを言語化できていない。
言語化できるってことは、単なる関数名以上にもっと一般的性質で意味を述べられて、抽象化できるってことだ。
その一般的性質を満たす実例が無数に存在し、かつその一般的性質が同じなら同じものであると言えるものだ。
もうちょっと、意味ってものについて真剣に考えなくちゃいけない。
それはおそらく、普通は **仕様** と呼ばれるものだ。
意味が仕様だとすれば、構文は **実装** だ。

じゃあどうすればいいのか。目標は

```
h :: A -> T -> U
h x t = ?
```

こうする。つまり分岐はつくらずに、 `?` の部分を一般的に実装する。
`f` = `g` と完全に構文的に一致している場合はいい。
ただ `f` ≠ `g` でかつその差がほんのちょっとってことは、おそらくそれが意味ってことだ。
たいていはそれをそのまま `f'` や `g'` に切り出す。
そして常に、 `f = h f'` かつ `g = h g'` が成り立てばいい。
これが抽象化だ。

*ここでもし、いやそれは抽象化じゃないって思うなら、抽象化とはなんなのかを真剣に言語化してみてほしい。
たぶん、簡単にはできないと思う。*

ただここで `x` となるなにかを見つけるときは公理的設計の 3 原則に注意する。
たとえば `x = f` や `x = g`  だと公理の自明性や定理の非自明性を満たさない。
一方で直和だと実例の無限性を満たさない。 `Int` や `Integer` は、可算無限個ある。
もちろんメモリの制約はあって実際には有限だけど、 ℤ は可算無限個ある。
`f` と `g` を有限の直和で、つまり単なる名前で共通化するんじゃなくて、
`f` と `g` を抽象化するっていうのは、すくなくとも可算無限個ある意味で抽象化するってことだ。
もちろん部分写像じゃだめだ。
つまり抽象化した瞬間に `f`, `g` と似たものがたくさん考えられるわけだ。
そしてその可算無限個ある意味の有限の実例が `f'`, `g'` でしかない。こういう一般的性質を考える。
それはおそらく、通常は **設定** (*configuration*) と呼ばれるものになるだろう。

これが構文と意味を分離するってこと。
`h` が構文の単位で、 `x` が意味の単位だ。

意味と構文を分離するっていうのは、実のところうまく設計されたライブラリでは、ごく自然に行われている。
たとえば Monad とかがそう。意味と構文を分離することこそが、再利用しやすいってことなんだ。
意味こそが具体的構造であり、構文こそが一般的操作だ。

数学で体系化された公理系なら、すでに意味と構文が分離されているから、
それを型クラスで定義するってのは、理に適っている。

ただ、アプリケーションにおける抽象化って？　それは考えれば考えるほど、難しい。
ただ基本的には、具体的な構造と一般的な操作を分離しておくことはおおよそ正しいってこと。
そしてここで具体的な構造とはなにか、一般的な操作はなにかということを言語化するなら、
具体的な構造とは意味であり、一般的な操作は構文だってこと。

問題はだいたい、構文と意味が密結合してるから生まれてるんだな、というか。
というよりも正しく抽象化されていれば、それはもはや具体的な構造から離れ、単なる構文でしかなくなるってことだ。

この考え方を推し進めると最終的にコードから意味がすべて取り除かれ単なる構文でしかなくなる。
意味は処理対象となる。つまり可算無限個考えられる仕様を処理する言語処理系になる。
メンテしにくいようでいて、テスト対象が劇的に減ってコードの重複は一切なくなりすべてが汎用的で、
ありとあらゆる自明な変更が一瞬ででき、非自明な機能拡張だけに注力できるようになる。
これは究極的にはプログラミングを自動化する行為とも言える。

ただデータのほうがメンテできなくなると問題だ。そこでわたしは明確にデータには弱い力、
コードには強い力を与えると責務を分離して、なんとか均衡を保ってメンテできている (気がする)。
データをシンプルで簡単に、コードを複雑で難しくする。
この設計だとコードよりもデータのほうが圧倒的に多くなる。
弱い力は多くてもわりとメンテできる。強い力は、多いとメンテできなくなるのだ。

この直観を得てからは、本当に開発が楽になったと思う。
