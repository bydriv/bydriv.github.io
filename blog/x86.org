#+SETUPFILE: ../setup.org
#+TITLE: x86 勉強メモ

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>x86.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-01-17">2018-01-17</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-01-17">2018-01-17</time>@@
#+END_UPDATED_AT

ひとまず， 勉強メモ的なものを残しておく．

* 基本的なこと

x86 というと， 通常は 32-bit のアーキテクチャを指す．
x86 を 64-bit に拡張したものがあり，
これは x86 64 とか， x64 などと呼ばれる．
しかし日常的には x86 と x64 をまとめて x86 と呼ぶこともある．

x86 の *命令セット* (/instruction set/) は，いわゆる機械語であって，
~mov~ のようなものは *アセンブラ* (/assembler/)の実装にすぎない．
なので x86 という *アセンブリ言語* (/assembly language/) が存在するわけではない．
しかし， 日常的には GAS や NASM が処理するアセンブリ言語のことを x86 と呼ぶこともある．

x86 の命令セットに含まれるそれぞれの命令は /opcode/ と呼ばれる．
~mov~ のような人間可読なものは *ニーモニック* (/mnemonic/) と呼ばれる．
ニーモニックの列を /opcode/ の列に変換することがアセンブラの仕事である．

ただ，実行形式は単なる /opcode/ の列ではなく，
通常， OS が必要とする情報も含んでいる． たとえば ELF や EXE のヘッダがそうである．
また同じ /opcode/ でも，システムコールなどはふるまいが OS に依存する．
これらが同じ CPU でも異なる OS では実行できない理由である．
しかし ELF にせよ EXE にせよ， (CPU が同じなら) 大部分は同じ /opcode/ の列である．

* レジスタ

レジスタは x86 と x64 で数が異なる．
x86 では 8 つ， x64 では 16 つである．

x64 の RAX レジスタを例にとると，
rax, eax, ax, al, ah は次に示す共用体のような関係にある．

#+BEGIN_SRC c
typedef union {
  struct {
    uint8_t al;
    uint8_t ah;
  };
  uint16_t ax;
  uint32_t eax;
  uint64_t rax; /* x64 のみ */
} rax_t;
#+END_SRC

つまりたとえば eax に 42 をいれると rax も 42 になる．
領域は同じで，アクセスする幅が異なる感じになっている．
しかしこの説明ではまだじゅうぶんではなくて，
たとえば eax に値をいれると rax の上位 32 bit は 0 で埋められるが，
ax ではそのまま残るなどの違いがある．
このへんの仕様は互換性を保つための歴史的経緯による産物らしい．

レジスタの一覧は次のとおり．
ただし 64-bit レジスタは x64 のみ．

- rax, eax, ax, al, ah
- rbx, ebx, bx, bl, bh
- rcx, ecx, cx, cl, ch
- rdx, edx, dx, dl, dh
- rsi, esi, si, sil (sih はない)
- rdi, edi, di, dil (dih はない)
- rbp, ebp, bp, bpl (bph はない)
- rsp, esp, sp, spl (sph はない)

次のレジスタは x64 のみ．

- r8, r8d, r8w, r8b
- r9, r9d, r9w, r9b
- r10, r10d, r10w, r10b
- r11, r11d, r11w, r11b
- r12, r12d, r12w, r12b
- r13, r13d, r13w, r13b
- r14, r14d, r14w, r14b
- r15, r15d, r15w, r15b

* XMM レジスタ

このへんは正直まだよくわかっていないのだが，
浮動小数点数をいれると高速化できるらしい．
このレジスタに入っている浮動小数点数専用の命令がいろいろある．
あと， Windows だと浮動小数点数はこのレジスタにいれて渡すことになっている．
(機械語には型がないと言ったな． あれは嘘だ)

* 命令など

命令はいろいろある．
列挙するのも面倒なくらいたくさんある．
これは正直覚えるしかない．
まあ ~mov~ だけでチューリング完全らしいので最悪 ~mov~ だけ覚えておくとよい．
あと ~lea~ は便利．

* 処理系など

x86 の処理系は当然 CPU だが，
アセンブラという意味では GAS と NASM が双璧という感じらしい．
GAS は gcc に付属してるはずなのでおそらくどの環境にもある．
しかし，玄人は NASM を使うというウワサもある．
