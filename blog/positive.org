#+SETUPFILE: ../setup.org
#+TITLE: Strictly Positive, または Coq がいかにして停止性を保証しているか

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>positive.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-01-17">2018-01-17</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-01-17">2018-01-17</time>@@
#+END_UPDATED_AT

以前 Coq みたいに停止性が保証された言語処理系を開発したいと思っていて，
いろいろ調べていたことがあった． そのときの知見をまとめておく．

まずよく知られているように， Coq の再帰には強い制限がある．
つまり， 再帰で渡せる値は構文的に小さいものにかぎられる．
はじめ， わたしはこれだけで停止性を保証できるのかと思っていたのだけど，
そうではなかった． じつは帰納的データ型の定義時にけっこういろいろ検査しなければならないらしい．

Haskell などのデータ型は， それ自身を含む型を定義できる．
これを *再帰型* (/recursive types/) という．
TaPL にも再帰型が載っているが， ある意味あれが structural な再帰型だとすると，
Haskell のようなデータ型は nominal な再帰型である．
OCaml ではバリアントというが，
厳密にはバリアントはそれ自身を含む型を定義できない (実際， Coq ではそうなっている)
ので バリアント + nominal な再帰型というのが正確なところであろう．
このようなデータ型は再帰型を含む以上， 再帰型にまつわるやっかいな問題もいっしょについてくる．

#+BEGIN_SRC sh :exports results :results html
pygmentize -l haskell -f html Y.hs
#+END_SRC

このようにして， なんと関数が再帰せずともデータ型の再帰のみで
Y コンビネータを定義できてしまうのである．

しかしじつは Coq でこのようなデータ型を定義しようとしても
*定義時に* 弾かれる． ~y :: (a -> a) -> a~ を定義せずとも，
~Rec~ 型を定義しようとするだけで弾かれてしまう．
では， それはいかにして実現されているのだろうか．
じつは Coq の帰納的データ型には， Strictly Positive という条件が課されているのである．
Strictly Positive は， 簡単にいえばデータ型を定義するときに，
~->~ の左側で再帰することを許さない条件である．
じつは Agda でも採用されているらしい．
くわしくは参考文献を参照されたし．

* References

- 4.5.2. Well-formed inductive definitions - https://coq.inria.fr/distrib/current/refman/cic.html#sec190
- Positivity Checking - http://agda.readthedocs.io/en/v2.5.3/language/positivity-checking.html
