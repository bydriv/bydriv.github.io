<!DOCTYPE html>
<html>
<head>
<title>HsYACC/HsLex の使い方</title>
<!-- 2018-01-29 Mon 18:15 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/prelude.css" />
<link rel="stylesheet" type="text/css" href="/css/highlight.css" />
</head>
<body>
<div id="content">
<h1 class="title">HsYACC/HsLex の使い方</h1>
<div class="location">
<p>
https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>hsyacc.html</strong>
</p>

</div>

<div class="created_at">
<p>
created at <time datetime="2018-01-29">2018-01-29</time>
</p>

</div>

<div class="updated_at">
<p>
updated at <time datetime="2018-01-29">2018-01-29</time>
</p>

</div>

<p>
最近 Haskell で HsYACC と HsLex というものをつくった．
HsYACC は LALR(1) 構文解析器生成系で，
HsLex は DFA 型の正規表現エンジンをもちいた字句解析器生成系である．
開発の動機は happy, alex が GHC を前提としたコードを出力するので
Haskell 2010 処理系でポータブルなコードを出力するものがほしいから，
単純に勉強したことを実装に落としこみたかったから， などである．
まだ安定しているわけでもなければ， 需要があるとも思えないが，
いちおうわたし自身のためにもその使い方を記しておく．
</p>

<p>
まずインストールについてだが，
いまのところ Hackage などには置いていないので，
自前でビルドするしかない．
とはいえ Stack を使用しているのでここで苦しむことはないはずである．
</p>

<pre class="example">
$ git clone git://github.com/bydriv/mhc.git
$ cd mhc
$ stack build
</pre>

<p>
こうすると <code>.stack-work</code> 以下に <code>hsyacc</code> コマンドと
<code>hslex</code> コマンドができあがるはずである．
</p>

<p>
コマンドのインターフェースはまだ調整中だが，
現状では次のように使う．
</p>

<pre class="example">
$ hsyacc &lt; Parsing.hsy &gt; Parsing.hs
$ hslex &lt; Lexing.hsl &gt; Lexing.hs
</pre>

<p>
次は <code>Parsing.hsy</code> と <code>Lexing.hsl</code> について軽く述べる．
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">HsYACC</h2>
<div class="outline-text-2" id="text-1">
<p>
<code>hsyacc</code> コマンドに与えるファイルの基本文法は次のとおり．
</p>

<pre class="example">
%module Parsing %where
%start nonterm
%{
header
%}
%%
rules
%%
footer
</pre>

<p>
<code>%module</code> はモジュール名を指定し，
<code>%start</code> は開始規則を指定する．
<code>header</code> と <code>footer</code> の部分には好きな Haskell のコードが書ける．
<code>rules</code> については形式的に述べるより例でもって説明したほうがわかりやすいと思うので後述する．
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">HsLEX</h2>
<div class="outline-text-2" id="text-2">
<p>
<code>hslex</code> コマンドに与えるファイルの基本文法は次のとおり．
</p>

<pre class="example">
%module Parsing %where
%{
header
%}
%%
rules
%%
footer
</pre>

<p>
<code>%module</code> はモジュール名を指定し，
<code>header</code> と <code>footer</code> の部分には好きな Haskell のコードが書ける． <code>rules</code> については，
HsYACC と同様に形式的に述べるより例でもって説明したほうがわかりやすいと思うので後述する．
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">例</h2>
<div class="outline-text-2" id="text-3">
<p>
なにはともあれ例を示す．
次に示すコードは，
テストも兼ねて実装した JSON のパーサである．
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Data/JSON/Parsing.hsy</h3>
<div class="outline-text-3" id="text-3-1">
<pre class="example">
%module Data.JSON.Parsing %where

%{
import qualified Data.RBMap as RBMap

type FALSE = ()
type NULL = ()
type TRUE = ()
type LBRACE = ()
type RBRACE = ()
type COMMA = ()
type COLON = ()
type LBRACKET = ()
type RBRACKET = ()
type NUMBER = Double
type STRING = String

data JSON =
    JSONFalse
  | JSONNull
  | JSONTrue
  | JSONObject (RBMap.RBMap STRING JSON)
  | JSONArray [JSON]
  | JSONNumber NUMBER
  | JSONString STRING
  deriving (Eq, Ord, Read, Show)

type Value = JSON
type False = JSON
type Null = JSON
type True = JSON
type Object = JSON
type Members = RBMap.RBMap STRING JSON
type Members_opt = Maybe Members
type Member = (STRING, JSON)
type Array = JSON
type Values = [JSON]
type Values_opt = Maybe Values
type Number = JSON
type String' = JSON
%}

%%

def rule value :=
  false
| null
| true
| object
| array
| number
| string'

def rule false :=
  FALSE

def rule null :=
  NULL

def rule true :=
  TRUE

def rule object :=
  LBRACE members RBRACE

def rule members :=
| member members_opt

def rule members_opt :=
| COMMA members

def rule member :=
  STRING COLON value

def rule array :=
  LBRACKET values RBRACKET

def rule values :=
| value values_opt

def rule values_opt :=
| COMMA values

def rule number :=
  NUMBER

def rule string' :=
  STRING

%%

semanticActions :: Monad m =&gt; SemanticActions m
semanticActions = SemanticActions
  { value_implies_false = return
  , value_implies_null = return
  , value_implies_true = return
  , value_implies_object = return
  , value_implies_array = return
  , value_implies_number = return
  , value_implies_string' = return
  , false_implies_FALSE = const $ return JSONFalse
  , null_implies_NULL = const $ return JSONNull
  , true_implies_TRUE = const $ return JSONTrue
  , object_implies_LBRACE_members_RBRACE = \() members () -&gt;
      return $ JSONObject members
  , members_implies = return RBMap.empty
  , members_implies_member_members_opt = \(prop, value) members_opt -&gt;
      return $ maybe (RBMap.singleton prop value) (RBMap.insert prop value) members_opt
  , members_opt_implies = return Nothing
  , members_opt_implies_COMMA_members = const (return . Just)
  , member_implies_STRING_COLON_value = \prop () value -&gt;
      return (prop, value)
  , array_implies_LBRACKET_values_RBRACKET = \() values () -&gt;
    return $ JSONArray values
  , values_implies = return []
  , values_implies_value_values_opt = \value values_opt -&gt;
      return $ maybe [value] (value:) values_opt
  , values_opt_implies = return Nothing
  , values_opt_implies_COMMA_values = const (return . Just)
  , number_implies_NUMBER = return . JSONNumber
  , string'_implies_STRING = return . JSONString }
</pre>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Data/JSON/Lexing.hsl</h3>
<div class="outline-text-3" id="text-3-2">
<pre class="example">
%module Data.JSON.Lexing %where

%{
import qualified Data.Char         as Char
import qualified Data.JSON.Parsing as Parsing
%}

%%

case (Initial, [' ' '\t' '\n' '\f' '\r']) =&gt; saWS
case (Initial, "false") =&gt; saFalse
case (Initial, "null") =&gt; saNull
case (Initial, "true") =&gt; saTrue
case (Initial, '{') =&gt; saLBrace
case (Initial, '}') =&gt; saRBrace
case (Initial, ',') =&gt; saComma
case (Initial, ':') =&gt; saColon
case (Initial, '[') =&gt; saLBracket
case (Initial, ']') =&gt; saRBracket
case (Initial, '-'?('0'|['1'-'9']['0'-'9']*)('.'['0'-'9']+)?(['e' 'E']['-' '+']?['0'-'9']+)?) =&gt;
  saNumber
case (Initial, '"'([^'"' '\\'] | '\\' (['"' '\\' '/' 'b' 'f' 'n' 'r' 't'] | 'u' ['0'-'9'|'A'-'F'|'a'-'f'] ['0'-'9'|'A'-'F'|'a'-'f'] ['0'-'9'|'A'-'F'|'a'-'f'] ['0'-'9'|'A'-'F'|'a'-'f']))*'"') =&gt;
  saString

%%

semanticActions :: Monad m =&gt; SemanticActions m (Maybe Parsing.Token)
semanticActions = SemanticActions
  { saWS = const $ return Nothing
  , saFalse = const $ return $ Just $ Parsing.FALSE ()
  , saNull = const $ return $ Just $ Parsing.NULL ()
  , saTrue = const $ return $ Just $ Parsing.TRUE ()
  , saLBrace = const $ return $ Just $ Parsing.LBRACE ()
  , saRBrace = const $ return $ Just $ Parsing.RBRACE ()
  , saComma = const $ return $ Just $ Parsing.COMMA ()
  , saColon = const $ return $ Just $ Parsing.COLON ()
  , saLBracket = const $ return $ Just $ Parsing.LBRACKET ()
  , saRBracket = const $ return $ Just $ Parsing.RBRACKET ()
  , saNumber = return . Just . Parsing.NUMBER . read
  , saString = return . Just . Parsing.STRING . unescape . init . tail }
  where
    unescape [] = []
    unescape ('\\' : '"' : s) =
      '"' : unescape s
    unescape ('\\' : '\\' : s) =
      '\\' : unescape s
    unescape ('\\' : '/' : s) =
      '/' : unescape s
    unescape ('\\' : 'b' : s) =
      '\b' : unescape s
    unescape ('\\' : 'f' : s) =
      '\f' : unescape s
    unescape ('\\' : 'n' : s) =
      '\n' : unescape s
    unescape ('\\' : 'r' : s) =
      '\r' : unescape s
    unescape ('\\' : 't' : s) =
      '\t' : unescape s
    unescape ('\\' : 'u' : x1 : x2 : x3 : x4 : s) =
      Char.chr (read ['0', 'x', x1, x2, x3, x4]) : unescape s
    unescape (c : s) =
      c : unescape s
</pre>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Data/JSON.hs</h3>
<div class="outline-text-3" id="text-3-3">
<pre class="example">
module Data.JSON where

import qualified Control.Monad.Identity as Identity
import qualified Data.JSON.Lexing       as Lexing
import qualified Data.JSON.Parsing      as Parsing
import qualified Data.Maybe             as Maybe

type JSON = Parsing.JSON

parse :: String -&gt; Maybe JSON
parse s =
  let (tokens0, s') = Identity.runIdentity $ Lexing.runLexing $ Lexing.lex Lexing.semanticActions s in
    case s' of
      [] -&gt;
        let tokens = Maybe.catMaybes tokens0 in
          case Identity.runIdentity $ Parsing.parse Parsing.semanticActions tokens of
            Nothing -&gt;
              Nothing
            Just (result, tokens') -&gt; do
              case tokens' of
                [] -&gt;
                  Just result
                _ -&gt;
                  Nothing
      _ -&gt;
        Nothing
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Appendix</h2>
<div class="outline-text-2" id="text-4">
<p>
HsLex, HsYACC 自体の字句解析，
構文解析も HsLex, HsYACC でおこなっている．
ゆえに完全な文法は次のリンクから参照することができる．
</p>

<ul class="org-ul">
<li><a href="https://github.com/bydriv/mhc/blob/master/Language/HsYacc/Parsing.hsy">https://github.com/bydriv/mhc/blob/master/Language/HsYacc/Parsing.hsy</a>
</li>
<li><a href="https://github.com/bydriv/mhc/blob/master/Language/HsYacc/Lexing.hsl">https://github.com/bydriv/mhc/blob/master/Language/HsYacc/Lexing.hsl</a>
</li>
<li><a href="https://github.com/bydriv/mhc/blob/master/Language/HsLex/Parsing.hsy">https://github.com/bydriv/mhc/blob/master/Language/HsLex/Parsing.hsy</a>
</li>
<li><a href="https://github.com/bydriv/mhc/blob/master/Language/HsLex/Lexing.hsl">https://github.com/bydriv/mhc/blob/master/Language/HsLex/Lexing.hsl</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">References</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li>Appel, Andrew W. 『最新コンパイラ構成技法』 2009.
</li>
<li>新屋良磨, 鈴木勇介, 高田謙. 『正規表現技術入門』 2015.
</li>
</ul>
</div>
</div>
</div>
</body>
</html>
