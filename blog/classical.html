<!DOCTYPE html>
<html>
<head>
<title>古典論理で →, ⊥ だけで ∧, ∨ を定義する話</title>
<!-- 2018-08-29 Wed 13:56 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="/css/prelude.css" />
<link rel="stylesheet" type="text/css" href="/css/highlight.css" />
</head>
<body>
<div id="content">
<h1 class="title">古典論理で →, ⊥ だけで ∧, ∨ を定義する話</h1>
<div class="location">
<p>
https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>classical.html</strong>
</p>

</div>

<div class="created_at">
<p>
created at <time datetime="2018-08-29">2018-08-29</time>
</p>

</div>

<div class="updated_at">
<p>
updated at <time datetime="2018-08-29">2018-08-29</time>
</p>

</div>

<p>
体系はどこまで小さくできるだろうか．
わたしがはじめ記号論理を学んだとき，
∧ や ∨ はほかの要素， つまり → に還元できない，
根源的な要素なのかどうかという疑問をもった．
結論からいうと， 直観主義では → だけで ∧ や ∨ を定義することは無理だが，
古典論理なら → と ⊥ だけで ∧ や  ∨ も定義できるということだそうだ．
</p>

<p>
古典論理で ∧ や ∨ を定義する方法はいろいろあるらしいが，
わたしが参照した現代数理論理学序説という書籍では，
つぎのように定義されている:
</p>

<ul class="org-ul">
<li>￢α = α→⊥
</li>
<li>α∧β = ￢(α→￢β)
</li>
<li>α∨β = (α→β)→β
</li>
<li>α⇄β = (α→β)∧(β→α)
</li>
</ul>

<p>
これでどうしてきちんと定義できたことになるのだろうか．
真理値表を書いてみることにしよう．
まずは， ￢α から:
</p>

<table>


<colgroup>
<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="left">α</th>
<th scope="col" class="left">α→⊥</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">⊤</td>
<td class="left">⊥</td>
</tr>

<tr>
<td class="left">⊥</td>
<td class="left">⊤</td>
</tr>
</tbody>
</table>

<p>
たしかにこれは，否定の定義に望むべく性質だろう．
</p>

<p>
∧ はすこしややこしい． そこで先に ∨ の真理値表を書いてみよう．
</p>

<table>


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="left">α</th>
<th scope="col" class="left">β</th>
<th scope="col" class="left">α→β</th>
<th scope="col" class="left">(α→β)→β</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">⊤</td>
<td class="left">⊤</td>
<td class="left">⊤</td>
<td class="left">⊤</td>
</tr>

<tr>
<td class="left">⊤</td>
<td class="left">⊥</td>
<td class="left">⊥</td>
<td class="left">⊤</td>
</tr>

<tr>
<td class="left">⊥</td>
<td class="left">⊤</td>
<td class="left">⊤</td>
<td class="left">⊤</td>
</tr>

<tr>
<td class="left">⊥</td>
<td class="left">⊥</td>
<td class="left">⊤</td>
<td class="left">⊥</td>
</tr>
</tbody>
</table>

<p>
たしかに， α または β のすくなくとも一方が真ならば，
全体としても真となり，両方が偽ならば，全体としても偽となる．
これは， ∨ の定義に望むべく性質である．
</p>

<p>
つぎは ∧　に行こう．
</p>

<table>


<colgroup>
<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">

<col  class="left">
</colgroup>
<thead>
<tr>
<th scope="col" class="left">α</th>
<th scope="col" class="left">β</th>
<th scope="col" class="left">￢β</th>
<th scope="col" class="left">α→￢β</th>
<th scope="col" class="left">￢(α→￢β)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">⊤</td>
<td class="left">⊤</td>
<td class="left">⊥</td>
<td class="left">⊥</td>
<td class="left">⊤</td>
</tr>

<tr>
<td class="left">⊤</td>
<td class="left">⊥</td>
<td class="left">⊤</td>
<td class="left">⊤</td>
<td class="left">⊥</td>
</tr>

<tr>
<td class="left">⊥</td>
<td class="left">⊤</td>
<td class="left">⊥</td>
<td class="left">⊤</td>
<td class="left">⊥</td>
</tr>

<tr>
<td class="left">⊥</td>
<td class="left">⊥</td>
<td class="left">⊤</td>
<td class="left">⊤</td>
<td class="left">⊥</td>
</tr>
</tbody>
</table>

<p>
ふむふむ． α と β の両方が真のとき，
またそのときにかぎり， 全体としても真となる．
これは， ∧ の定義に望むべく性質である．
</p>

<p>
⇄ は簡単なので省略する．
</p>

<p>
ところが， これだけではまだ定義として不十分である．
通常は公理として与えられる演算も定義できなければならない．
これらの演算を定義するには， Peirce の法則（すなわち排中律）が必要である．
</p>

<p>
証明を書くこともできるが， HTML で証明図を書くのはたいへんなので許してほしい．
とりあえず， 同等のものがつぎのプログラムである:
<a href="https://github.com/wejournal/lamb/blob/987b1ef642e076b07dbd76c9aaf4773adf117107/examples/classical.lam">https://github.com/wejournal/lamb/blob/987b1ef642e076b07dbd76c9aaf4773adf117107/examples/classical.lam</a>
</p>

<p>
Peirce の法則を call/cc と考えると， Scheme ならこれを実行するプログラムが書ける:
<a href="https://gist.github.com/bydriv/699255226b85f37c2aa6c5c6de4206bb">https://gist.github.com/bydriv/699255226b85f37c2aa6c5c6de4206bb</a>
</p>

<p>
ところで，直観主義では → と ⊥ で ∧ や ∨ が定義できないので，
∧ や ∨ をもたない直観主義命題論理は，
直観主義命題論理の {→, ⊥}-断片というらしい．
さらに ⊥ も含まない論理は， 含意断片というらしい．
含意というのは， → のことである．
</p>

<p>
先ほどの Lamb における公理 <code>peirce</code> をとりのぞくと直観主義命題論理の
{→, ⊥}-断片となる．
さらに命題定数 <code>false</code> と 公理 <code>absurd</code> をとりのぞくと含意断片となる．
もし，タプルやバリアントを言語に加えれば最小論理となるらしい
(最小論理は <code>false</code> や <code>absurd</code> は含まないが，
∧ や ∨ は含む論理)．
</p>

<p>
なお， church encoding で組や和を定義する方法は，
不要な型変数が陽に現れてしまうので ∧ や ∨ を定義できたことにはならない．
(ということなのだろうか)． System F なら型変数が現れないように定義できるので OK ，ということらしい．
</p>

<p>
なので Lamb は正確にいえば直観主義命題論理というより， 含意断片論理，
ということになるのだろうか．
</p>
</div>
</body>
</html>
