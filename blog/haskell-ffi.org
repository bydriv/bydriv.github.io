#+SETUPFILE: ../setup.org
#+TITLE: Haskell 2010 の FFI 周りについて

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>haskell-ffi.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-01-22">2018-01-22</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-01-22">2018-01-22</time>@@
#+END_UPDATED_AT

Haskell 2010 で定義されている FFI について記しておく．
まず， 簡単に FFI の例を見てみよう．

#+BEGIN_SRC sh :exports results :results html
pygmentize -l haskell -f html FFI.hs
#+END_SRC

順に見ていく．

- ~foreign import~ は外部の関数を呼びだすためのキーワードである．
- ~ccall~ は呼びだし規約で，
  ほかにも ~stdcall~, ~cplusplus~, ~jvm~, ~dotnet~,
  あるいは処理系依存の呼びだし規約が指定できる．
  ~ccall~ の実装は必須だが，
  そのほかのものは optional である．
  処理系はこのほかの呼びだし規約を実装してもよい．
  たとえば GHCJS は ~javascript~ を実装している．
- ~safe~ はシステムが外部関数を呼びだすときのふるまいを指定し，
  このほかにも ~unsafe~ が指定できる．
  ~safe~ は非効率的だが安全に呼びだされることが保証される．
  ~unsafe~ は危険だがオーバーヘッドが少ないものを意図しているものの，
  規格上のふるまいは未定義である． よく勘違いされるが，
  ~IO~ や GHC の ~-XSafe~ 拡張とは関係がない
  (~-XSafe~ 拡張は終域に ~IO~ が含まれない FFI をコンパイルエラーにする
  言語拡張である． したがって， 上記の ~sin~ や ~cos~ のような関数は弾かれる．
  ~-XTrustworthy~ はそのような関数をコンパイルエラーにはせずに，
  プログラマが安全な関数のみを使っていることを信頼する言語拡張である)．
- ~static~ は静的なアドレスであることを意味し， 省略可能である．
  ~math.h~ は C のヘッダファイルを指定するのだが， 省略可能である．
  ~sin~ などは C の関数名 (より正確にはリンクする関数名) であり，
  ~&sin~ などとすることで ~Ptr~ 型で関数ポインタを得ることができる．
  ほかにも ~dynamic~, ~wrapper~ などが指定できる． こちらは省略できない．
  なお， まぎらわしいが静的/動的リンクとは関係がない．
- ~csin~ や ~Double -> Double~ などは Haskell の関数名と型である．
  FFI で指定できる型は C の型との共通部分にかぎられる．
  くわしくは規格を参照されたし．

* Foreign

~Foreign~ モジュールは FFI に関するいろいろなユーティリティ関数などを提供する．
~Data.Bits~, ~Data.Int~, ~Data.Word~, ~Foreign.Ptr~,
~Foreign.ForeignPtr~, ~Foreign.StablePtr~, ~Foreign.Storable~,
~Foreign.Marshal~ などをリエクスポートしている．
~Data.Bits~ モジュールはビット演算に関する操作を提供している．
~Data.Int~ は符号付つき整数に関する関数など，
~Data.Word~ は符号なし整数に関する関数などである．

* Foreign.Ptr

~Foreign.Ptr~ モジュールはポインタを表す型を提供する．
ポインタに関する操作などは，
主に ~Foreign.Marshal~ モジュールにある．

* Foreign.Marshal

~Foreign.Marshal~ モジュールはポインタに関する操作などを提供する．
~Foreign.Marshal.Alloc~, ~Foreign.Marshal.Array~,
~Foreign.Marshal.Error~, ~Foreign.Marshal.Utils~ などをリエクスポートしている．

* Foreign.Marshal.Alloc

~Foreign.Marshal.Alloc~ モジュールはメモリ確保などの関数を提供する．

~mallocBytes :: Int -> O (Ptr a)~ は，
バイト単位でメモリを確保するための関数である．

~malloc :: Storable a => IO (Ptr a)~ は ~mallocBytes (sizeOf undefined)~ と等しい
(~sizeOf~ は ~Foreign.Storable.Storable~ 型クラスのメソッドである)．
これは遅延評価前提の関数なので， ~-XStrict~ 拡張 や ~-XStrictData~ 拡張と相性が悪い．

~allocaBytes :: Int -> (Ptr a -> IO b) -> IO b~ 関数は
~mallocBytes~ 関数と似ているが， ヒープではなくスタックに確保する．
若干黒魔術めいている．

~alloca :: Storable a => (Ptr a -> IO b) -> IO b~ 関数は
~allocaBytes (sizeOf undefined)~ と等しい．
やはり遅延評価前提なので正格評価と相性が悪い．

ほかにも ~realloc~, ~reallocBytes~, ~free~ などがあるので調べてほしい．

* Foreign.Marshal.Array

~Foreign.Marshal.Alloc~ と似ているモジュールで， メモリ確保などを提供する．
違いは配列を確保するところである．
たとえば ~mallocArray :: Storable a => Int -> IO (Ptr a)~ で
~sizeOf undefined * n~ のサイズの配列を確保できる．

* Foreign.Storable

~Foreign.Storable~ 関数はデータのシリアライズ，
デシリアライズのための型クラスを提供する．
~malloc~ 関数などで頻繁に現れるので理解しておく必要がある．
たとえば， ~data Point = Point Int Int~
という型を ~Storable~ のインスタンスにしたいとしよう．
すると， 次のようになる．

#+BEGIN_SRC sh :exports results :results html
pygmentize -l haskell -f html Storable.hs
#+END_SRC

~poke~ 関数は Haskell のデータ型を C の型，
すなわちバイト列へシリアライズし， ポインタへ格納する．
~peek~ 関数でデシリアライズしてデータをとりだす，
という感じである．

注意すべきこととしては， ~sizeOf~ と ~alignment~ の引数を使ってはいけないということ．
ほとんどの場合， 引数として ~undefined~ が渡される．
どういう経緯でこういうインターフェースになったのかは知らない．
型推論との兼ね合いな気はする (個人的には， 非常にまずい設計になっていると感じる)．

* Foreign.StablePtr

特定のポインタを明示的に GC の管理から外したいときに使う．
ものすごくパフォーマンスが重要な場合に使えるのかもしれない．
わたしは使ったことがない．

* Foreign.ForeignPtr

外部のポインタを GC に管理させたいときに使う．
これは便利．

* Foreign.C

~Foreign.C~ モジュールは C とのインターフェースとなる型を提供する．
