#+SETUPFILE: ../setup.org
#+TITLE: 古典論理メモ

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>klassisch.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-08-29">2018-08-29</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-08-29">2018-08-29</time>@@
#+END_UPDATED_AT

古典論理とラムダ計算， プログラミング言語に関するメモ．

* 排中律

α∨￢α という命題．
直観主義論理に排中律を加えると古典論理になる．
排中律と同値な命題には， つぎのようなものがある:

- *パースの法則* (/Peirce's Law/): ((α→β)→α)→α (call/cc の型)
- *2重否定の除去* : ￢￢α→α

排中律の 2重否定 ￢￢(α∨￢α) は直観主義でも証明可能．
ゆえに 2重否定の除去があれば排中律も証明できる．

* グリベンコの定理

ある命題が *古典論理で証明可能* なことと，
その命題の 2重否定が *直観主義論理で証明可能* なことは同値である，
という定理． (正確には，もうすこし一般化されているっぽい)

** CPS 変換

CPS (継続渡しスタイル) というのは関数の書き方の話．
CPS 変換というのは，ある関数をそれと同値な CPS で書かれた関数に変換すること．

たとえば

#+BEGIN_EXAMPLE
def f x := h (g x)
#+END_EXAMPLE

みたいにあったとすると

#+BEGIN_EXAMPLE
def f' x k := g' x (^y. h' y k)
#+END_EXAMPLE

というふうに変換される． g', h' は g, h を CPS 変換したもの．
CPS 変換するとすべての関数呼びだしが末尾呼出になるので，
すべての関数を末尾呼出最適化できるようになる．
なので， 自動的にスタックオーバーフローしなくなる．

さて， CPS 変換した関数の型について考えてみると，
もし f が

#+BEGIN_EXAMPLE
val f : 'a -> 'b
#+END_EXAMPLE

ならば，

#+BEGIN_EXAMPLE
val f' : 'a -> ('b -> 'c) -> 'c
#+END_EXAMPLE

となることがわかる．

'c は任意の型になれるので，この特殊な場合として
⊥ を考えることにより，

#+BEGIN_EXAMPLE
val f' : 'a -> ('b -> ⊥) -> ⊥
#+END_EXAMPLE

となる．
ところで ￢α = α→⊥ であるから，

#+BEGIN_EXAMPLE
val f' : 'a -> ￢￢'b
#+END_EXAMPLE

となることがわかるだろう．

おっと， 2重否定が現れてしまった．
つまり， CPS 変換というのは， ある命題の証明図が与えられたとき，
その命題を2重否定した命題の証明図を求める手続きなのであった．
