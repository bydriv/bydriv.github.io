#+SETUPFILE: ../setup.org
#+TITLE: 2019年の準備

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>2018-11-01.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-11-01">2018-11-01</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-11-01">2018-11-01</time>@@
#+END_UPDATED_AT

今日は2018年11月1日．
昨日は2018年10月31日，ハロウィンでした．
ところでハロウィンというのはもともとはケルトの祭日らしい．
ケルトの文化では11月1日が元日で， 10月31日というのは大晦日にあたる日だったそうです．
というわけで， 新年あけましておめでとうございます (？)．

2019年の準備をそろそろ始めないとなァ，と思っていたところだったのですけど，
ちょうど11月1日がケルトでは元日とされるらしいので，
もう新年を迎えたつもりで，新年の抱負みたいなことをしてゆきたいと思います．

今年やったことなどは [[./2018-10.org][2018-9, 2018-10 の進捗まとめ]] に書いたのですけど，
2019年やりたいこととしては，まだ書いていない．
書く必要あるのか，というのもあるけど，
いちおう書くことでキモチをしっかりさせるみたいな効果はあります．
なので書いてゆこうと思う．

2019年にやりたいことのひとつはゲーム開発．
今年もいちおう小さなゲームならつくれたけど，
まァ満足できたとはいえない．

もうひとつやりたいのはコンパイラというか，言語開発．
これはうん，どういう路線にするのかいまでも迷っているみたいなのがある．

最近は計算複雑性理論や計算可能性理論に興味がある．
計算複雑性理論というのは，大雑把にいえば *ある問題を解くのに，どれくらい複雑な計算が必要か*
考えるというもの． ここでいう複雑さというのは，大別すれば *時間計算量* と *空間計算量* のふたつ．
時間計算量というのは *ある問題を解くのに，どれくらい時間が必要か* ということで，
空間計算量というのは， *ある問題を解くのに，どれくらいメモリが必要か* ということ．

関数型言語の型システムはすきなのだけれど，
こういった計算複雑性についてはナイーブなところがあると感じている．
たとえば， 配列の添え字アクセス ~xs[n]~ は O(1) なのに対し，
リストの添え字アクセス ~nth(xs, n)~ は O(n) なのに，
関数型言語のたいていの型システムではこれらが同じ型とされてしまう
(たとえば型クラスの制約として計算量が O(1) であることを要求したりできない)．

いまわたしが関心があるのは，そういった計算量の考えかたを型システムに盛りこむこと．
といっても，簡単にはできそうにもないのでどうしようかなァ，
みたいなことを考えている．

* 言語開発

計算複雑性理論の複雑性クラスを参考にしたいと思っている．
たとえば， *RE* (帰納的可算言語のクラス) と
*PR* (原始再帰関数のクラス)
を型によって区別できる，など．
構文はテキトウなのだがこんな感じ:

#+BEGIN_EXAMPLE
val f : Int -> PR Int
val g : Int -> RE Int
#+END_EXAMPLE

*PR* ⊆ *RE* だから，

#+BEGIN_EXAMPLE
val RE : PR a -> RE a
#+END_EXAMPLE

は認めてよい． ~RE a -> PR a~ は実装(証明)できない．

推論規則をどうすればいいのか？
それはよくわかっていない．
ひとつヒントはあり，
~for~ ループで書けるプログラムは *PR* (原始再帰関数) で書けるプログラムと厳密に等しい
(実際，それを根拠に実装された言語として https://en.wikipedia.org/wiki/LOOP_(programming_language) などがある)
から，

#+BEGIN_EXAMPLE
n : PR int    m : PR int    i : PR int |- x : PR unit
_____________________________________________________
         for i = n to m do x done : PR unit
#+END_EXAMPLE

というふうにすることができる．

チューリングマシンが認識する言語は帰納的可算言語というらしい．
複雑性クラスでは *RE* と呼ばれる．
つまりわれわれが *RE* で表したいのはチューリング完全な関数だから，
~while~ は認めてもよかろう:

#+BEGIN_EXAMPLE
 x : RE bool    y : RE unit
___________________________
while x do y done : RE unit
#+END_EXAMPLE

** そもそもこういうふうに区別する意義はあるのか

*PR* や *RE* を区別したい第一の意義は，
*PR* の関数はすべて全域関数だが *RE* の関数は部分関数である可能性があるということ．

全域関数と部分関数を区別したい，という需要はあると思うのだけど，
最近はチューリング完全な体系でそれをやるのはナンセンスというキモチがある．
なぜかというと，チューリング完全な体系というのはすべての計算可能関数が書けるのだが，
計算可能関数というのは定義的に自然数から自然数への部分関数なので，
チューリング完全な体系で部分関数を追放するのは土台無理な話なのである．

だが， *部分関数ではなく，全域関数だけを書きたい* というキモチはある．
さてどうするか．

まず問題になってくるのは，全域関数かどうか判定することだがこれは停止性問題があるので難しい．
パターンマッチを網羅どうのという話ではなく， たとえば(構文はテキトウだが)

#+BEGIN_EXAMPLE
fun head (x :: _) = x
  | head nil = head nil
#+END_EXAMPLE

とかされたらわれわれにはどうしようもない．
例外ではなく無限ループをするようにすれば，
チューリング完全な言語なら部分関数は書けてしまうワケです．
こう言い換えてもいい．
*チューリング完全ならば，部分関数も書ける*
もしくは *チューリング完全の定義には，部分関数も含まれる* なんてね．

となると，部分関数を排除する試み(すくなくともコーディング規約のようなものではなく，
チャンと部分関数が書けない言語を設計するならば)チューリング完全性も捨てることになる．

……というのは言いすぎで，チューリング完全な必要があるならチューリング完全に，
ないならもうちょっと制約の強い体系で書けてもいいんじゃないの，
ということです．
それが *RE* と *PR* の意図するところで，
*RE* は *チューリング完全かつ部分関数* を書くもので，
*PR* は *チューリング不完全かつ全域関数* を書くもの．
~main~ 関数は ~val main : RE unit~ とか型をつける．
~val head : list a -> PR (option a)~  とかそんな．

*PR* は全域関数というより原始再帰関数のクラスで，
原始再帰関数はすべて全域関数だし，
日常的に必要な関数のほとんどはこれで書ける．
ただし，全域関数がすべて原始再帰関数というわけではない(たとえばアッカーマン関数などがある)ので，
~val head : list a -> total (option a)~ とか
~val main : partial unit~ とかするのは避けている．
(*PR* は ~for~ の推論規則で原始再帰関数だけを書けることが保証できるが，
~total~ みたいなタグをつけてすべての全域関数が書ける言語を設計するのは，たぶんかなり難しいし，
その労力に見合わないと思う)．

** 参照

実際のところマジメな話，参照はあったほうが楽というのが本音だと思う．
無理に関数型プログラミングするより参照を使ったほうが楽という場合は多い．
わたしは関数型であれ手続き型であれ楽な方法を選びたい．
ただ参照を言語に加えるならかなり慎重にならないといけないのはまちがいない．

参照を考えるうえで厄介なのは参照が再帰をするために使えるという事実で，
たとえば

#+BEGIN_EXAMPLE
let
  val f : ref (int -> int) = ref (fn x => x)
  val fib : int -> int = fn x =>
    if x = 0 then 0
    else if x = 1 then 1
    else !f (x - 2) + !f (x - 1)
in
  f := fib
end
#+END_EXAMPLE

のようにすることで ~fib~ の定義内で ~fib~ 自身を参照することができるため再帰ができてしまう．
多相性とかも関係ないので Relaxing the Value Restriction みたいなのでは解決できない．
そもそも Value Restriction にすらひっかからない．

この点についても https://en.wikipedia.org/wiki/LOOP_(programming_language) を参考にしてみると，
LOOP には参照というか変数はあることがわかる．
ただし，この変数は数値のみ格納できる．
とはいえ， 数値ではなく文字列にしても問題はなさそうだし，
代数的データ型を格納しても問題なかろう．

ということで，関数の参照はつくれない，というふうに制限することを考えている．
すくなくとも関数の参照をつくった時点でチューリング完全になることはまちがいないので，
関数の参照を扱えるとしても *RE* のみで，
*PR* では関数の参照は扱えないべきである．

配列のような mutable な構造も同様の問題があるので，
やはり関数の配列のようなものはすくなくとも *PR* ではつくれないようにすべきだろう．

** 再帰型

再帰型は recursive types for free! という論文にある通り covariant の位置でのみ許すようにする．
すくなくとも *PR* では covariant の位置でのみ再帰できて，
*RE* では contravariant でも再帰できる，というふうにする．

もっと単純に，関数の再帰型はつくれないとしてもいい．
contravariant な型変数が出現するのは関数のみなので，これでも同様の効果が得られる．
関数のポインタがつくれない，関数の再帰型はできないとしたほうがおそらくプログラマにとっては理解が直観的だと思われる．
hungry function のようなものは書けなくなるが，
実用上はあまり問題はないだろう．

** 再帰

再帰自体はできたほうが便利で， Coq みたいに値の構造による帰納法的なものができたらいいかもしれない．
まだあまり詰められていない．

** もっと細かい複雑性クラスを扱えるようにするか

そもそも *PR* と *RE* を区別できるような言語をつくろう，
というのは， ~for~ や ~while~ で書けるプログラムの集合が *PR* や *RE* になるから，
*PR* しか書けないようにするには ~for~ しか書けないようにすればいいだけなので実装が簡単だから．
*DTIME* とか *EXPTIME* を区別できるようにするには，
*どういう推論規則で検査すればEXPTIMEしか書けないと保証できるか* ということがわからないので，
まだ考えていない．

たとえば ~for~ すら使わないなら定数時間，みたいなことはできるんじゃない？
みたいなことはなんか思ってる．
ただ，理論的な下地がなければ自信がでない感はある．

*PR* や *RE* 以外のクラスを扱えるようにするなら，まずは定数時間を扱えるようにしたい……のだけど，
定数時間を扱う複雑性クラスに名前がついているのか知らない（あるのか？）ので，
便宜的に *K* で表すことにする．
そうすると

#+BEGIN_EXAMPLE
(* 配列のランダムアクセス *)
val sub : array a -> int -> K a
#+END_EXAMPLE

というふうになる．
明らかに *K* ⊆ *PR* だから，

#+BEGIN_EXAMPLE
val PR : K a -> PR a
#+END_EXAMPLE

は認めてよい．

定数時間の関数 (終域に *K* がついた関数のみに依存する関数) はやはり定数時間で終了すると期待されるので，
推論規則もそんなに難しくはならないだろう．

リテラルは *K* をつけるといいかもしれない．

~for~ や ~while~ は当然書けないし，それらを使った関数も書けない．

/Note/: *K* がついた関数やデータは設定記述言語に適していると思われる．

** ホーア論理について

計算複雑性とは関係ないのだけど，ホーア論理みたいなものも採用したい気がしている．

理由はいくつかあるのだけど，大きな理由は多重チェックを避けるため．

よくあるパターンとしてある値が特定の条件を満たすこと (null でないとか， 空でないとか)
をある関数内でチェックしているのにもかかわらずさらにその関数の呼び出し側でチェックするということがある．

#+BEGIN_EXAMPLE
fun f xs =
  if null xs then
    raise <..>
  else
    <..>

fun g xs =
  if null xs then
    raise <..>
  else let
    val y = f xs
  in
    <..>
  end
#+END_EXAMPLE

こういうことをしてしまう場合はほんとに多く，
オーバーヘッドは無視できる程度だとしてコードのあちこちでチェックしているのでとにかく見通しが悪いうえ，
どのチェックをはぶいても問題ないのかが自明ではない (のでバグりやすい)．

こういうコードは少ないときはいいけど，どこではぶいてよいのかわからないのでとにかく片っ端からあちこちに
書く戦略になりやすく，そうすると当然のことながらコードのあちこちに同じような条件が大量に書かれていてアレ．

そうではなくホーア論理的なもので事前条件と事後条件をこう書きたい．

#+BEGIN_EXAMPLE
fun f xs = {
  xs /= nil
} <..> {
  xs /= nil
}

fun g xs ={
  xs /= nil
} let
  val y = f xs
in
  <..>
end {
  xs /= nil
}
#+END_EXAMPLE

こうすれば条件部を機械的に検査することも可能になるし，
引数が満たすべき条件が明示されていて読みやすく(効用には個人差があります)，
コード生成も工夫すれば条件のチェックをひとつにまとめられるはず．

さらに条件も型に含めることが可能になる．

#+BEGIN_EXAMPLE
val f : (xs:list a) -> {xs /= nil} <..> {xs /= nil}
val g : (xs:list a) -> {xs /= nil} <..> {xs /= nil}
#+END_EXAMPLE

ドキュメントとして関数の事前条件と事後条件が明示されるのは単純にうれしい．
あと， シンプルに事前条件を満たさずに呼びだせばコンパイル時にチェックすることもできる．

#+BEGIN_EXAMPLE
fun h xs = {} g xs {} (* 事前条件の不一致でエラーが報告される *)

(* 事前条件を ``にぎりつぶす'' 場合． *)
fun h xs = {
} case xs of
    nil =>
      NONE
  | _ :: _ =>
      SOME (g xs) (* xs /= nil であることは，処理系によって推論される *)
{
}
#+END_EXAMPLE

* ゲーム開発

話は変わるけどゲーム開発をしたいみたいなキモチはいまでもある．

ゲームは，いちおういまできてるものはいまできてるものでよくて，
これからつぎのゲームを開発したい．

1作めは今年開発したのでよくて， 2作めという感じ(？)．

このへんはもうちょっと計画を練らないとなァという感じです．

とりあえず，なにがボトルネックになっているかを明らかにしたいけど，
短期間でゲームをつくっちゃうひととか見てると，
やっぱ *そのゲームをプレイして，なにが楽しいのか* をちゃんと伝えれるひとが強いみたいな感じがある．

たぶんかけた時間とか労力みたいなのはあんま関係なくて，
*これはこれこれこういうことをするゲームです* ということを説明できるといいんじゃないかという感じがある．
プレイヤーにそのゲームを遊ぶ動機をつけさせるというか．

たぶんシステムから考えてるのがよくなくて，
プレイヤーの視点というか自分だったらどういうゲームが遊びたいの？
みたいなのが抜けてる感がある．

プレイヤーがゲームを遊ぶ目的ってジャンルによって異なるけど，
たとえば格ゲーなら対戦相手を倒すことだったり，
RPGだったらストーリーを進めるためだったりする．
でもRPGで雑魚敵を倒すことを目的にして遊ぶひとってあんまいないよね．
みたいなことを考えると，やっぱプレイヤーが遊ぶ動機になる要素を重点的に開発して，
遊ぶ動機になりにくい部分はあとまわしにしたほうがいいのかなぁとか．

もちろんジャンルみたいな考えかたに縛られる必要はなくてそのゲームでなにがおもしろいのかを伝えられればいいんだけど，
わたしのゲームはまだ伝える力に乏しいというか，まだなにがおもしろいのかを自分でもよくわからずに開発している気がする．

すくなくとも，雑魚敵を倒して楽しいゲームにしたくはないしするつもりもなくて，
ストーリーを進めたりマップを攻略するのが楽しいゲームにしたいわけです．

そう考えると，やっぱ今後の課題として *遊びごたえのあるマップデザイン* みたいなのがあるのかなァ，
とか． マップデザインが完全に素人なのがボトルネックになっているのかもしれない．

ストーリーはなんか，大雑把な方針として研究員の手記みたいなのを集めることで間接的に想像できるようにするというか，
そんな感じにしたいとかなんとか思っている．

まあともかくそんな感じ．
