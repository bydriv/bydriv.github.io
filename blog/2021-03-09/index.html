<!DOCTYPE html>

<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/etc/site/style.css">
  <title>bydriv.github.io</title>
  <meta property="og:url" content="https://bydriv.github.io/blog/2021-03-09/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="bydriv.github.io" />
  <meta property="og:description" content="多対多の関係を扱うデータ構造について" />
  <meta property="og:site_name" content="bydriv.github.io" />
  <meta property="og:image" content="https://bydriv.github.io/etc/site/thumbnail.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <script type="text/javascript" src="/etc/site/kt.js"></script>
</head>

<div class="navigation"><!--
--><div class="left"><!--
--><a class="section" href="/">&#x221A;</a><!--
--><a class="section" href="/blog">&#x1F4DD;</a><!--
--><a class="section" href="/illustration">&#x1F3A8;</a><!--
--><a class="section" href="/photo">&#x1F4F7;</a><!--
--><a class="section" href="/literature">&#x1F516;</a><!--
--><a class="section" href="/world">&#x1F4BD;</a><!--
--><a class="section" href="/comic">&#x1F4AD;</a><!--
--><a class="section" href="/vr">&#x1F9E9;</a><!--
--><a class="section" href="/misc">&#x1F4C1;</a><!--
--></div>&nbsp;<!--
--><div class="right"><!--
--><a class="holoio section" href="#holoio">&#x22EF;</a><!--
--></div><!--
--></div><!--
--><div id="holoio">
<div class="navigation"><!--
--><div class="left"><!--
-->&nbsp;</div>&nbsp;<!--
--><div class="right"><!--
--><a class="section" href="#">&#x2573;</a><!--
--></div><!--
--></div>

<div class="kt-month-calendar" data-today="true"></div>
</div>

<article>
<h1 id="多対多の関係を扱うデータ構造について">多対多の関係を扱うデータ構造について</h1>
<p>多くのプログラミング言語には <code>Map</code> と呼ばれるデータ構造があります。これは <strong>部分写像</strong> を表すデータ構造です。部分写像というと、いわゆる (プログラムの) 関数を想像するかもしれません。部分写像を表現する方法はいろいろあって、そのうちのいくつかの方法として、プログラムによる表現とデータ構造による表現があるわけですね。</p>
<pre><code>-- 部分写像のデータ構造による表現
f :: Map Int Int
f = Map.fromList [(1, 2), (2, 3)]

-- 部分写像のプログラムによる表現
g :: Int -&gt; Maybe Int
g 1 = Just 2
g 2 = Just 3
g _ = Nothing</code></pre>
<p>さて部分写像というのは <strong>関係</strong> の一種です。つまりある種の性質を満たす関係を部分写像と呼んでいます。</p>
<p>関係とは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in{}A</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in{}B</annotation></semantics></math> のような集合の要素同士の関係性を定義するものです。部分写像の場合は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(a)=b</annotation></semantics></math> という関係を定義しているのですね。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A=B</annotation></semantics></math> の場合もありますし <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≠</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">A\neq{}B</annotation></semantics></math> の場合もあります。</p>
<p>同値関係 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a=b</annotation></semantics></math> や順序関係 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mrow></mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">a\leq{}b</annotation></semantics></math> も関係です。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>∈</mo><mrow></mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">c\in{}C</annotation></semantics></math> のように <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> 項関係に一般化することもでき二項演算 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a+b=c</annotation></semantics></math> や <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a\times{}b=c</annotation></semantics></math> のような関係もあります (関係においては戻り値は引数との関係と考えるので、戻り値も含めると <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow></mrow><mi>A</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mrow></mrow><mi>B</mi><mo>,</mo><mi>c</mi><mo>∈</mo><mrow></mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">a\in{}A,b\in{}B,c\in{}C</annotation></semantics></math> のようなみっつの集合の要素の関係を考えることになります。もちろん戻り値のない関係もあります) 。</p>
<p>より一般的には <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>R</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">aRb</annotation></semantics></math> や <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">R\left(a,b\right)</annotation></semantics></math>のように記述します。</p>
<p>関係を直積集合として定義する場合には <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>⊆</mo><mrow></mrow><mi>A</mi><mo>×</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">G\subseteq{}A\times{}B</annotation></semantics></math> として <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>G</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">R=(A,B,G)</annotation></semantics></math> と定め <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>R</mi><mi>b</mi><mo accent="false">⇔</mo><mrow></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow></mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">aRb\Leftrightarrow{}\left(a,b\right)\in{}G</annotation></semantics></math> と定義します。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> は <strong>グラフ</strong> と呼ばれます。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> や <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> という集合を考えることが関係とグラフの違いです。</p>
<p>さて <strong>写像</strong> とは <strong>左全域的</strong> かつ <strong>右一意的</strong> な関係を言います。部分写像とは写像のうち、左全域的の条件を課さない関係です。左全域的とはすべての <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in{}A</annotation></semantics></math> について <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in{}B</annotation></semantics></math> なる <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow></mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">\left(a,b\right)\in{}G</annotation></semantics></math> が（すくなくともひとつ）存在することを言います（複数あってもいい）。右一意的とは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow></mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">\left(a,b\right)\in{}G</annotation></semantics></math> かつ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow></mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">\left(a,c\right)\in{}G</annotation></semantics></math> ならば <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b=c</annotation></semantics></math> であること (つまり、それぞれの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in{}A</annotation></semantics></math> にはたったひとつの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in{}B</annotation></semantics></math> のみが関係すること) を言います。</p>
<p>これはデータ構造の言葉で言えば、いわゆる <strong>多対一</strong> の関係です。以下の例では <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="true" form="postfix">}</mo></mrow><mo>⊆</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">\left\{1,2\right\}\subseteq{}A</annotation></semantics></math> が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">{</mo><mn>5</mn><mo stretchy="true" form="postfix">}</mo></mrow><mo>⊆</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">\left\{5\right\}\subseteq{}B</annotation></semantics></math> と関係していて <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">{</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="true" form="postfix">}</mo></mrow><mo>⊆</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">\left\{3,4\right\}\subseteq{}A</annotation></semantics></math> が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">{</mo><mn>6</mn><mo stretchy="true" form="postfix">}</mo></mrow><mo>⊆</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">\left\{6\right\}\subseteq{}B</annotation></semantics></math> と関係しています。</p>
<pre><code>-- f(a) = b &lt;=&gt; a belongs to b
f 1 = Just 5
f 2 = Just 5
f 3 = Just 6
f 4 = Just 6
f _ = Nothing</code></pre>
<p>(論理包含と部分集合の関係に似ていますね)</p>
<p>プログラムの開発には多対一だけでなくさまざまな関係を扱う必要があります。その代表例が <strong>グラフ</strong> でしょう。グラフは <strong>頂点</strong> 同士の関係と考えることができるわけです。写像だけでなく一般の関係を扱うことはできるのでしょうか。</p>
<h2 id="疎グラフと密グラフ">疎グラフと密グラフ</h2>
<p>頂点の集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math> と辺の集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>E</mi><annotation encoding="application/x-tex">E</annotation></semantics></math> の数に着目したとき <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>,</mo><mi>m</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>E</mi><mo stretchy="true" form="postfix">|</mo></mrow></mrow><annotation encoding="application/x-tex">n=\left|V\right|,m=\left|E\right|</annotation></semantics></math> とすると <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math> の最大値は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mrow></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n\times{}\left(n-1\right)</annotation></semantics></math> つまり <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>E</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>≤</mo><mrow></mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left|E\right|\leq{}\left|V\right|\left(\left|V\right|-1\right)</annotation></semantics></math> となります。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>E</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left|E\right|=\left|V\right|\left(\left|V\right|-1\right)</annotation></semantics></math> はすべての頂点がすべての頂点と辺でむすばれている、つまり完全グラフの場合です。この辺の数と頂点の数の量を比べて、辺の数が頂点の数に比して圧倒的に多いものを密グラフ、そうでないものを疎グラフと言います。疎グラフは比較的一対一対応に近い状態で、密グラフは多対多対応の状態です。</p>
<p>密グラフはほとんどすべての辺が存在するので、素朴な表のようなデータ構造で扱うのが簡単です。つまり、以下のように <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow><mo>×</mo><mrow></mrow><mrow><mo stretchy="true" form="prefix">|</mo><mi>V</mi><mo stretchy="true" form="postfix">|</mo></mrow></mrow><annotation encoding="application/x-tex">\left|V\right|\times{}\left|V\right|</annotation></semantics></math> の正方行列を考えればいい：</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mo>⊥</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>e</mi><mn>12</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msub><mi>e</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>e</mi><mn>21</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⊥</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><msubsup><mi>e</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋱</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd></mtr><mtr><mtd columnalign="center"><msubsup><mi>e</mi><mrow><mi>n</mi><mn>1</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>e</mi><mrow><mi>n</mi><mn>2</mn></mrow><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><mo>⊥</mo><mrow></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">M=\left(\begin{array}{cccc}\bot{}&amp;e_{12}^{}&amp;\cdots{}&amp;e_{1n}\\e_{21}^{}&amp;\bot{}&amp;\cdots{}&amp;e_{2n}^{}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\e_{n1}^{}&amp;e_{n2}^{}&amp;\cdots{}&amp;\bot{}\end{array}\right)</annotation></semantics></math></p>
<p>一方で疎グラフを表のようなデータ構造でもつと、表のほとんどの部分に辺が存在しない状態になってしまい非効率的です。</p>
<p>ちょうど配列に対する連想配列のように、上記のような行列に対する連想行列（？）のようなデータ構造がほしいわけです。</p>
<p>素朴な方法として <code>Map (a, b) Bool</code> がありますが、これは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow></mrow><mi>A</mi><mo>×</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">\left(a,b\right)\in{}A\times{}B</annotation></semantics></math> から検索することは高速なのですが、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in{}A</annotation></semantics></math> や <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">b\in{}A</annotation></semantics></math> のみで表の行や列にまとめてアクセスすることが難しい。 <code>(Map a (Set b), Map b (Set a))</code> は計算量は申し分ないのですが、二分木よっつの組み合わせでできており、あまり効率的に思えませんし操作のインターフェースも猥雑です。 <code>type Relation a b = (Map a (Set b), Map b (Set a))</code> として操作を定義すればインターフェースは改善できますが、データ構造としてもうすこし最適なものを考えたいわけです。</p>
<p>関係をグラフと考える場合には <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mo>=</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">A=B=V</annotation></semantics></math> として <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>,</mo><mi>u</mi><mo>∈</mo><mrow></mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">v,u\in{}V</annotation></semantics></math> について <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>R</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">vRu</annotation></semantics></math> なることを頂点同士が辺でむすばれていると考えます。無向グラフと有向グラフのように向きを区別する場合には <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>R</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">vRu</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>R</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">uRv</annotation></semantics></math> を区別すればよいわけです。そこで多対多の関係を扱えるデータ構造を設計できれば、自然とグラフも扱うことができるようになります。</p>
<h2 id="二分探索に適した順序">二分探索に適した順序</h2>
<p>配列に対する連想配列というアナロジーから二分探索木を直積集合に応用すればよいことは自然な発想です。しかしそう単純にはいかない。というのは、直積というのは線型ではないからです。</p>
<p>つまり整数や有理数のようなものを並べると直線になるのに対し、直積は表 (平面) になり、 3 次元だと立体になります。 4 次元、 5 次元とどんどん増やすことはできますが、このようなものを単純に二分探索することは難しいわけです。</p>
<p>一方で直線状のものは二分探索で非常に効率的に扱えることから、上記のような高次元の対象を直線状になおして扱えばよいのではないかというのが最初の直観です。</p>
<p><strong>線型代数</strong> でうまくできないかといろいろと式をこねこねしていましたが、そうしているうちにもっとシンプルな方法を思いつきました。</p>
<p>関係をある種の表としてとらえるのであれば、</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mo>⋯</mo></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋱</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>m</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>m</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>m</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G=\left(\begin{array}{cccc}\left(a_1^{},b_1^{}\right)&amp;\left(a_2^{},b_1^{}\right)&amp;\cdots&amp;\left(a_n^{},b_1^{}\right)\\\left(a_1^{},b_2^{}\right)&amp;\left(a_2^{},b_2^{}\right)&amp;\cdots{}&amp;\left(a_n^{},b_2^{}\right)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\\left(a_1^{},b_m^{}\right)&amp;\left(a_2^{},b_m^{}\right)&amp;\cdots{}&amp;\left(a_n^{},b_m^{}\right)\\\end{array}\right)</annotation></semantics></math></p>
<p>となるでしょう。</p>
<p>必要なことは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a\in{}A</annotation></semantics></math> のみを与えられても <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>∈</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">b\in{}B</annotation></semantics></math> のみを与えられても効率的に検索が可能なデータ構造です。たとえば <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a_1^{}\in{}A</annotation></semantics></math> の列のすべての関係を列挙したり、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">b_2^{}\in{}B</annotation></semantics></math> の行のすべての関係を列挙したり、あるいは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>∈</mo><mrow></mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">\left(a_2^{},b_2^{}\right)\in{}G</annotation></semantics></math> という関係が存在するかを迅速に判定したいわけです。</p>
<p>さてここで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><annotation encoding="application/x-tex">a_i^{}</annotation></semantics></math> や <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><annotation encoding="application/x-tex">b_j^{}</annotation></semantics></math> の <strong>添え字</strong> に着目します。</p>
<p>まず <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> が長方形になっている場合には、正方形になる (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n=m</annotation></semantics></math> になる) ように適当に拡大した表を考えます (ほんとうにメモリ上にそういう表をつくる必要はなく、あくまで計算しやすくするため。適当に <code>Nothing</code> とかで埋めればよい)。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mo>⋯</mo></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋱</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd></mtr><mtr><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>n</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>n</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center"><mo>⋯</mo><mrow></mrow></mtd><mtd columnalign="center"><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>n</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>n</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G=\left(\begin{array}{cccc}\left(a_1^{},b_1^{}\right)&amp;\left(a_2^{},b_1^{}\right)&amp;\cdots&amp;\left(a_n^{},b_1^{}\right)\\\left(a_1^{},b_2^{}\right)&amp;\left(a_2^{},b_2^{}\right)&amp;\cdots{}&amp;\left(a_n^{},b_2^{}\right)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\\left(a_1^{},b_n^{}\right)&amp;\left(a_2^{},b_n^{}\right)&amp;\cdots{}&amp;\left(a_n^{},b_n^{}\right)\\\end{array}\right)</annotation></semantics></math></p>
<p>ここで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i=j</annotation></semantics></math> となるような対角線の添え字に着目します。すると</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"></mtd></mtr><mtr><mtd columnalign="center"></mtd><mtd columnalign="center"><mn>2</mn></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"></mtd></mtr><mtr><mtd columnalign="center"></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"><mo>⋱</mo></mtd><mtd columnalign="center"></mtd></mtr><mtr><mtd columnalign="center"></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"></mtd><mtd columnalign="center"><mi>n</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G=\left(\begin{array}{cccc}1&amp;&amp;&amp;\\&amp;2&amp;&amp;\\&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;n\\\end{array}\right)</annotation></semantics></math></p>
<p>こうなっています。</p>
<p>ここに <strong>直線</strong> があるので、この直線を二分探索します。この対角線のある点を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math> とすると、その点に <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">ik</annotation></semantics></math> 行と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">kj</annotation></semantics></math> 列の関係の集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><msubsup><mi>w</mi><mi>k</mi><mrow></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>k</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>k</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>k</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">row_k^{}=\left\{\left(a_1^{},b_k^{}\right),\left(a_2^{},b_k^{}\right),\cdots{},\left(a_i^{},b_k^{}\right)\right\}</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><msubsup><mi>l</mi><mi>k</mi><mrow></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>k</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>k</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>k</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">col_k^{}=\left\{\left(a_k^{},b_1^{}\right),\left(a_k^{},b_2^{}\right),\cdots{},\left(a_k^{},b_j^{}\right)\right\}</annotation></semantics></math> を格納します。ただし、関係をそのまま格納すると重複が生まれるので、実際には <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>k</mi><mrow></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msubsup><mi>a</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">A_k^{}=\left\{a_1^{},a_2^{},\cdots{},a_i^{}\right\}</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>B</mi><mi>k</mi><mrow></mrow></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><msubsup><mi>b</mi><mn>1</mn><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mn>2</mn><mrow></mrow></msubsup><mo>,</mo><mo>⋯</mo><mrow></mrow><mo>,</mo><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">}</mo></mrow></mrow><annotation encoding="application/x-tex">B_k^{}=\left\{b_1^{},b_2^{},\cdots{},b_j^{}\right\}</annotation></semantics></math> を格納すればじゅうぶんです。 たとえば <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>k</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(a_k^{},b_j^{}\right)</annotation></semantics></math> を格納する場合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>k</mi><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><msubsup><mi>A</mi><mi>j</mi><mrow></mrow></msubsup></mrow><annotation encoding="application/x-tex">a_k^{}\in{}A_j^{}</annotation></semantics></math> となり、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>a</mi><mi>k</mi><mrow></mrow></msubsup><annotation encoding="application/x-tex">a_k^{}</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><annotation encoding="application/x-tex">b_j^{}</annotation></semantics></math> が別々の場所に分解されて格納されることに注意してください。</p>
<p>つまり上述の <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(n,n\right)</annotation></semantics></math> 行列と同値なデータ表現として、次のような <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>3</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(n,3\right)</annotation></semantics></math> 行列に変形します。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><msubsup><mi>A</mi><mn>1</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>B</mi><mn>1</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mn>2</mn></mtd><mtd columnalign="center"><msubsup><mi>A</mi><mn>2</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>B</mi><mn>2</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd></mtd></mtr><mtr><mtd columnalign="center"><mi>n</mi></mtd><mtd columnalign="center"><msubsup><mi>A</mi><mi>n</mi><mrow></mrow></msubsup></mtd><mtd columnalign="center"><msubsup><mi>B</mi><mi>n</mi><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G=\left(\begin{array}{ccc}1&amp;A_1^{}&amp;B_1^{}\\2&amp;A_2^{}&amp;B_2^{}\\\vdots&amp;\vdots&amp;\vdots&amp;\\n&amp;A_n^{}&amp;B_n^{}\end{array}\right)</annotation></semantics></math></p>
<p>このようにすればもはや長さ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> の配列と同じように扱え、単純な二分木として実装が可能になるというわけです。</p>
<p>関係 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\left(a,b\right)</annotation></semantics></math> を追加したとき、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> とが一ヶ所に格納されることが重要です。</p>
<p>ポインタであれば 8 byte のコピーで済むのですが、一ヶ所にあるということは単純にコピーしても問題ないということなので、たとえば Rust などの言語では Rc を使わずに済んだり、データベースの永続化時などには有利です。</p>
<h2 id="より基礎的な話題">より基礎的な話題</h2>
<p>さて上記のようなデータ表現のより基礎的な話題について考えてみます。</p>
<p>まず <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,\cdots,n</annotation></semantics></math> という添え字になっている対角線は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i=j</annotation></semantics></math> となる部分で、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">a_i^{}\in{}A</annotation></semantics></math> の、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">b_j^{}\in{}B</annotation></semantics></math> の添え字にそれぞれなっています。この <strong>添字集合</strong> を考えると <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mrow></mrow><mi>I</mi><mo>,</mo><mi>j</mi><mo>∈</mo><mrow></mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">i\in{}I,j\in{}J</annotation></semantics></math> となっています。そこで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">I=J</annotation></semantics></math> であること、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> は <strong>全順序集合</strong> であること、そして <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">A,B,I</annotation></semantics></math> のあいだに以下の関係が満たされることを公理と考えます。</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mrow></mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mrow></mrow><mi>I</mi><mo>.</mo><mo>∀</mo><mrow></mrow><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>a</mi><mi>j</mi><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>A</mi><mo>.</mo><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><mo>=</mo><msubsup><mi>a</mi><mi>j</mi><mrow></mrow></msubsup><mo accent="false">⇔</mo><mrow></mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>i</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>a</mi><mi>j</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\exists{}f:A\rightarrow{}I.\forall{}a_i^{},a_j^{}\in{}A.a_i^{}=a_j^{}\Leftrightarrow{}f\left(a_i^{}\right)=f\left(a_j^{}\right)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mrow></mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo accent="false">→</mo><mrow></mrow><mi>I</mi><mo>.</mo><mo>∀</mo><mrow></mrow><msubsup><mi>b</mi><mi>i</mi><mrow></mrow></msubsup><mo>,</mo><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo>∈</mo><mrow></mrow><mi>B</mi><mo>.</mo><msubsup><mi>b</mi><mi>i</mi><mrow></mrow></msubsup><mo>=</mo><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo accent="false">⇔</mo><mrow></mrow><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>b</mi><mi>i</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>b</mi><mi>j</mi><mrow></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\exists{}g:B\rightarrow{}I.\forall{}b_i^{},b_j^{}\in{}B.b_i^{}=b_j^{}\Leftrightarrow{}g\left(b_i^{}\right)=g\left(b_j^{}\right)</annotation></semantics></math></li>
</ul>
<p>印象的には、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> が一対一の関係にある、つまり <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> の要素と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math> の要素を自然に同一視できる (コンピュータの言葉で言えばバイナリにエンコーディングできる) ということです。</p>
<p>もし <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> が <strong>高々可算</strong> の集合であれば <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> への単射が存在するので、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></mrow><annotation encoding="application/x-tex">I=\mathbb{N}</annotation></semantics></math> と置けば上記の関係は自明に満たされます。</p>
<h3 id="n-次元への拡張"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> 次元への拡張</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math> 次元での表でも同様の表現が可能です。 (必要な集合は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msubsup><mi>B</mi><mi>k</mi><mrow></mrow></msubsup><mo>⊆</mo><mrow></mrow><mi>A</mi><mo>×</mo><mrow></mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">AB_k^{}\subseteq{}A\times{}B</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msubsup><mi>C</mi><mi>k</mi><mrow></mrow></msubsup><mo>⊆</mo><mrow></mrow><mi>A</mi><mo>×</mo><mrow></mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">AC_k^{}\subseteq{}A\times{}C</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><msubsup><mi>C</mi><mi>k</mi><mrow></mrow></msubsup><mo>⊆</mo><mrow></mrow><mi>B</mi><mo>×</mo><mrow></mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">BC_k^{}\subseteq{}B\times{}C</annotation></semantics></math> のみっつ)。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center"><mn>1</mn></mtd><mtd columnalign="center"><mi>A</mi><msubsup><mi>B</mi><mn>1</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mi>A</mi><msubsup><mi>C</mi><mn>1</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mi>B</mi><msubsup><mi>C</mi><mn>1</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mn>2</mn></mtd><mtd columnalign="center"><mi>A</mi><msubsup><mi>B</mi><mn>2</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mi>A</mi><msubsup><mi>C</mi><mn>2</mn><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mi>B</mi><msubsup><mi>C</mi><mn>2</mn><mrow></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"><mo>⋮</mo></mtd><mtd columnalign="center"></mtd></mtr><mtr><mtd columnalign="center"><mi>n</mi></mtd><mtd columnalign="center"><mi>A</mi><msubsup><mi>B</mi><mi>n</mi><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mi>A</mi><msubsup><mi>C</mi><mi>n</mi><mrow></mrow></msubsup></mtd><mtd columnalign="center"><mi>B</mi><msubsup><mi>C</mi><mi>n</mi><mrow></mrow></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G=\left(\begin{array}{cccc}1&amp;AB_1^{}&amp;AC_1^{}&amp;BC_1^{}\\2&amp;AB_2^{}&amp;AC_2^{}&amp;BC_2^{}\\\vdots&amp;\vdots&amp;\vdots&amp;\\n&amp;AB_n^{}&amp;AC_n^{}&amp;BC_n^{}\end{array}\right)</annotation></semantics></math></p>
<p>ここでさらに <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msubsup><mi>B</mi><mi>k</mi><mrow></mrow></msubsup></mrow><annotation encoding="application/x-tex">AB_k^{}</annotation></semantics></math> などを上述のような表現で再帰的に定義することもできます。</p>
<h2 id="ハッシュ値の場合">ハッシュ値の場合</h2>
<p>ハッシュ関数のような場合一対一の関係にはならないかもしれません。その場合には添字集合をすこし工夫すればよいのです。つまり</p>
<pre><code>type A = String
type B = String
type I = (Hash, Either A B)</code></pre>
<p>などとすればよろしい。一意性はタプルの右の要素によって担保されていて、また辞書順であれば、ほとんどの比較はハッシュ値の比較のみで済むので高速です。</p>
<p>もちろん実際に実装する場合には、添え字が重複を許可するように実装することも考えられます。</p>
<h2 id="通常の-map-での表現">通常の Map での表現</h2>
<pre><code>type R i a b = Map i (Set a, Set b)</code></pre>
<p>のようにすれば通常の <code>Map</code> でも同様の表現は可能です。</p>
<p>添字集合は自然数である必要はありません。 <code>R Integer</code> でも問題ありませんし、 <code>R (Either a b)</code> でもいいわけです。</p>
<p>(後者の表現はおそらくもっともナイーブ)。</p>
<p>うまく型をつけることで <code>Left x</code> から <code>(Set.empty, ys)</code> が返ってくること、 <code>Right y</code> から <code>(xs, Set.empty)</code> が返ってくることは表現できるかもしれません。</p>
<h2 id="実装">実装</h2>
<p>集合を <code>[a]</code> や <code>[b]</code> ではなく二分木にしたり、平衡二分木化も検討中ですがとりあえずのプロトタイプ。</p>
<pre><code>module Relation
  ( R, Relation
  , empty
  , insert, selectLeft, selectRight, betweenLeft, betweenRight
  , insertBy, selectLeftBy, selectRightBy, betweenLeft, betweenRight ) where

import qualified Data.Char  as Char
import qualified Data.Int   as Int
import qualified Data.List  as List
import qualified Data.Ratio as Ratio
import qualified Data.Word  as Word

class Finite a where
  count :: a -&gt; Integer

class Countable a where
  injection :: a -&gt; Rational

type Relation = R Rational

data R i a b =
    Empty
  | Node i [a] [b] (R i a b) (R i a b)
  deriving (Read, Show)

--------------------------------------------------------------------------------

empty :: R i a b
empty =
  Empty

--------------------------------------------------------------------------------

insert :: (Countable a, Countable b) =&gt; a -&gt; b -&gt; Relation a b -&gt; Relation a b
insert =
  insertBy injection injection

selectLeft :: (Countable a, Countable b) =&gt; a -&gt; Relation a b -&gt; [b]
selectLeft =
  selectLeftBy injection

selectRight :: (Countable a, Countable b) =&gt; b -&gt; Relation a b -&gt; [a]
selectRight =
  selectRightBy injection

betweenLeft :: (Countable a, Countable b) =&gt; a -&gt; a -&gt; Relation a b -&gt; [b]
betweenLeft =
  betweenLeftBy injection

betweenRight :: (Countable a, Countable b) =&gt; b -&gt; b -&gt; Relation a b -&gt; [a]
betweenRight =
  betweenRightBy injection

--------------------------------------------------------------------------------

insertBy :: Ord i =&gt; (a -&gt; i) -&gt; (b -&gt; i) -&gt; a -&gt; b -&gt; R i a b -&gt; R i a b
insertBy f g x y r =
  insertAt f g (f x) [] [y] (insertAt f g (g y) [x] [] r)

selectLeftBy :: Ord i =&gt; (a -&gt; i) -&gt; a -&gt; R i a b -&gt; [b]
selectLeftBy f x =
  snd . lookupAt (f x)

selectRightBy :: Ord i =&gt; (b -&gt; i) -&gt; b -&gt; R i a b -&gt; [a]
selectRightBy g y =
  fst . lookupAt (g y)

betweenLeftBy :: Ord i =&gt; (a -&gt; i) -&gt; a -&gt; a -&gt; R i a b -&gt; [b]
betweenLeftBy f x x&#39; =
  concat . snd . between (f x) (f x&#39;)

betweenRightBy :: Ord i =&gt; (b -&gt; i) -&gt; b -&gt; b -&gt; R i a b -&gt; [a]
betweenRightBy f x x&#39; =
  concat . fst . between (f x) (f x&#39;)

--------------------------------------------------------------------------------

compareBy :: Ord i =&gt; (a -&gt; i) -&gt; a -&gt; a -&gt; Ordering
compareBy f x x&#39; =
  compare (f x) (f x&#39;)

unionBy :: Ord i =&gt; (a -&gt; i) -&gt; [a] -&gt; [a] -&gt; [a]
unionBy =
  foldr . List.insertBy . compareBy

insertAt ::
  Ord i =&gt; (a -&gt; i) -&gt; (b -&gt; i) -&gt; i -&gt; [a] -&gt; [b] -&gt; R i a b -&gt; R i a b
insertAt f g i xs ys Empty =
  Node i xs ys Empty Empty
insertAt f g i xs ys (Node j xs&#39; ys&#39; lhs rhs) =
  case compare i j of
    LT -&gt;
      Node j xs&#39; ys&#39; (insertAt f g i xs ys lhs) rhs
    EQ -&gt;
      Node j (unionBy f xs&#39; xs)  (unionBy g ys&#39; ys) lhs rhs
    GT -&gt;
      Node j xs&#39; ys&#39; lhs (insertAt f g i xs ys rhs)

lookupAt :: Ord i =&gt; i -&gt; R i a b -&gt; ([a], [b])
lookupAt _ Empty =
  ([], [])
lookupAt i (Node j xs ys lhs rhs) =
  case compare i j of
    LT -&gt;
      lookupAt i lhs
    EQ -&gt;
      (xs, ys)
    GT -&gt;
      lookupAt i rhs

between :: Ord i =&gt; i -&gt; i -&gt; R i a b -&gt; ([[a]], [[b]])
between _ _ Empty =
  ([], [])
between i j (Node k xs ys lhs rhs)
  | i &gt; k &amp;&amp; k &gt;= j =
      ([], [])
  | i &lt;= k &amp;&amp; k &lt; j =
      let
        (xss, yss) = between i j lhs
        (xss&#39;, yss&#39;) = between i j rhs
      in
        (xss ++ xs : xss&#39;, yss ++ ys : yss&#39;)
  | i &lt;= k &amp;&amp; k &gt;= i =
      between i j lhs
  | i &gt; k &amp;&amp; k &lt; i =
      between i j rhs

--------------------------------------------------------------------------------

instance Finite Char where
  count _ =
    toInteger (Char.ord maxBound)

instance Finite Int where
  count _ =
    toInteger (maxBound :: Int) - toInteger (minBound :: Int)

instance Finite Int.Int8 where
  count _ =
    toInteger (maxBound :: Int.Int8) - toInteger (minBound :: Int.Int8)

instance Finite Int.Int16 where
  count _ =
    toInteger (maxBound :: Int.Int16) - toInteger (minBound :: Int.Int16)

instance Finite Int.Int32 where
  count _ =
    toInteger (maxBound :: Int.Int32) - toInteger (minBound :: Int.Int32)

instance Finite Int.Int64 where
  count _ =
    toInteger (maxBound :: Int.Int64) - toInteger (minBound :: Int.Int64)

instance Finite Word.Word where
  count _ =
    toInteger (maxBound :: Word.Word)

instance Finite Word.Word8 where
  count _ =
    toInteger (maxBound :: Word.Word8)

instance Finite Word.Word16 where
  count _ =
    toInteger (maxBound :: Word.Word16)

instance Finite Word.Word32 where
  count _ =
    toInteger (maxBound :: Word.Word32)

instance Finite Word.Word64 where
  count _ =
    toInteger (maxBound :: Word.Word64)

--------------------------------------------------------------------------------

instance Countable Char where
  injection = toRational . Char.ord

instance Countable Int where
  injection = toRational

instance Countable Int.Int8 where
  injection = toRational

instance Countable Int.Int16 where
  injection = toRational

instance Countable Int.Int32 where
  injection = toRational

instance Countable Int.Int64 where
  injection = toRational

instance Countable Word.Word where
  injection = toRational

instance Countable Word.Word8 where
  injection = toRational

instance Countable Word.Word16 where
  injection = toRational

instance Countable Word.Word32 where
  injection = toRational

instance Countable Word.Word64 where
  injection = toRational

--------------------------------------------------------------------------------

instance Countable Integer where
  injection = toRational

instance Integral a =&gt; Countable (Ratio.Ratio a) where
  injection = toRational

instance (Finite a, Countable a) =&gt; Countable [a] where
  injection [] =
    0
  injection (x : xs) =
    injection x + injection xs * toRational (count x) + 1</code></pre>
</article>
