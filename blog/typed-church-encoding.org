#+SETUPFILE: ../setup.org
#+TITLE: 単純型つきラムダ計算でチャーチエンコーディングする件の話をしましょうか

#+BEGIN_LOCATION
@@html:https://<a href="/">bydriv.github.io</a>/<a href="/blog">blog</a>/<strong>typed-church-encoding.html</strong>@@
#+END_LOCATION

#+BEGIN_CREATED_AT
created at @@html:<time datetime="2018-08-01">2018-08-01</time>@@
#+END_CREATED_AT

#+BEGIN_UPDATED_AT
updated at @@html:<time datetime="2018-08-01">2018-08-01</time>@@
#+END_UPDATED_AT

チャーチエンコーディングというものがある．
ラムダ計算で数値だとかそういうものをラムダ項で表そうというものである．
厳密にはチャーチエンコーディングのほかにスコットエンコーディングというものもあるが本筋ではないので割愛する．

現在， [[https://github.com/wejournal/lamb][Lamb]] という処理系を開発している．
これは単純型つきラムダ計算を冠頭多相という(let多相とも呼ばれる)簡単な多相性で拡張した体系の処理系である．
もともと *型なし* ラムダ計算および *System F* では，
チャーチエンコーディングをすることで bool や nat というデータ型を表せることは知っていたのだが，
*単純型つき* ラムダ計算ではどうなのか，ということは知らなかった．
それでいろいろ試行錯誤したことをメモしておく．

ラムダ計算(Lambda Calculus)はもともとハット計算(Hat Calculus)と呼ばれていたらしい
(参考: The Letter Before Lambda is Hat: A Reconstruction of Church's Hat Calculus)．
ASCII にはラムダという記号がなく，
プログラム言語の構文はふつう ASCII の範囲内の文字で設計されるため，
Lamb ではラムダを表す文字として ~^~ を採用している．
そこでこの記事では， ラムダの代わりに ~^~ という記号をもちいることにする．

まず， 型なしラムダ計算では bool はつぎのように表せる．

#+BEGIN_EXAMPLE
true := ^x. ^y. x
false := ^x. ^y. y
#+END_EXAMPLE

必要な演算は簡単に定義できる．

#+BEGIN_EXAMPLE
not := ^p. p false true
and := ^p. ^q. p q false
or := ^p. ^q. p true q
#+END_EXAMPLE

つぎにこれらの型を考えてみる．
単純型つきラムダ計算なので，多相性はない．そこで ~A~ という単相の型を固定しておいて，
~B := A -> A -> A~ と定義して ~B~ を bool を表す型と考えることにする．
すると ~true~ と ~false~ は，つぎのような型になる．

#+BEGIN_EXAMPLE
true : B
false : B
#+END_EXAMPLE

演算の型はつぎのとおり．

#+BEGIN_EXAMPLE
not : (B -> B -> B) -> B
and : (B -> B -> B) -> B -> B
or : (B -> B -> B) -> B -> B
#+END_EXAMPLE

おや？　なにかがおかしい．
ふつうに考えれば，それぞれの演算は次のような型にならなければならない．

#+BEGIN_EXAMPLE
not : B -> B
and : B -> B -> B
or : B -> B -> B
#+END_EXAMPLE

なにがいけなかったのだろうか．
問題は， ~not~, ~and~, ~or~ の定義にある．
項に型をつけてみよう．

#+BEGIN_EXAMPLE
not := ^p : B -> B -> B. p false true
and := ^p : B -> B -> B. ^q : B. p q false
or := ^p : B -> B -> B. ^q : B. p true q
#+END_EXAMPLE

~true~ がすでに ~true : B~ なのだから， ~p true q~ のように渡せば当然， ~p : B -> B -> B~
となる．

~p : B~ となってほしいわけだから， ~B = A -> A -> A~ であることを思いだせば，
~p~ に渡せるのは ~A~ のみであって， ~B~ が渡せないことがわかるだろう．

そもそもチャーチエンコーディングを型つけするには Rank 2 Types が必要なのかもしれない，
と思って若干諦め気味だったのだが，ググったらけっこう簡単に解決できるようだった．

https://cstheory.stackexchange.com/questions/10085/can-boolean-algebra-be-expressed-in-simply-typed-lambda-caclulus

のコメントにあるのだが，つぎのようにすればよいようである．

#+BEGIN_EXAMPLE
not := ^p. ^x. ^y. p y x
and := ^p. ^p. ^x. ^y. p (q x y) y
or := ^p. ^q. ^x. ^y. p x (q x y)
#+END_EXAMPLE

ははあ， なるほど．
うまいこと考えはりますなぁ．

こうすれば見事型がつぎのようになって，万事解決というわけである．

#+BEGIN_EXAMPLE
not : B -> B
and : B -> B -> B
or : B -> B -> B
#+END_EXAMPLE

どうやらこの方法はリストや自然数などにも応用が利きそうである．
正直途中で単純型つきラムダ計算でチャーチエンコーディングするのは無理なんじゃないかと思い始めていたので，
よかったよかった．

* 件の話

10年ほどまえ，クダンの話をしましょうかというラノベを読んでいた．
それ以来，わたしのなかで件(クダン)といえばこのラノベに登場する少女であった．
件という漢字を書くたびに彼女のことを思いだすのである．
この記事のタイトルは，最初～する件についてとしようとしていたのだが，
～する件まで書いたとき，ふと彼女のことを思いだしてしまって，タイトルを変えた．

最近，過去を追いかけることが多くなった．
もう手に入らないのにもかかわらず．
それで青春時代に見たもの読んだものを何度も見て読んでしまう．
この記事とは関係ないことだが，個人の日記レベルの記事なので書いておく．
