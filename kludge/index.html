<!DOCTYPE html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Kludge</title>

<link rel="stylesheet" type="text/css" href="/css/prelude.css">
<link rel="stylesheet" type="text/css" href="/css/github-markdown.css">
<style>
  div#hd {
    height: 160px;
    margin: 0;
    padding: 0;

    background-image: url("/img/hd.png");
    background-position: center;
  }
  div#turing-machine:target ~ div#index > div#default-index-group > div#turing-machine-index {
    color: #000000;
    background-color: #00FFFF;
  }

  div#turing-machine:target ~ div#contents > div#turing-machine-contents {
    max-height: none;

    top: 0;
    z-index: -1000;
    opacity: 1;
  }
  div#language:target ~ div#index > div#default-index-group > div#language-index {
    color: #000000;
    background-color: #00FFFF;
  }

  div#language:target ~ div#contents > div#language-contents {
    max-height: none;

    top: 0;
    z-index: -1000;
    opacity: 1;
  }
</style>
<div id="container">
  <div id="home" class="default anchor"></div>
  <div id="turing-machine" class="anchor"></div>
  <div id="language" class="anchor"></div>
  <div id="hd"></div>
  <h1>Kludge</h1>
  <div id="index">
    <div id="default-index-group" class="default level-0 index-group">
      <div id="default-index" class="default index"><a href="#home">HOME</a></div>
      <div id="turing-machine-index" class="index"><a href="#turing-machine">TURING-MACHINE</a></div>
      <div id="language-index" class="index"><a href="#language">LANGUAGE</a></div>
    </div>
  </div>
  <div id="contents">
    <div id="default-contents" class="default contents">
      <div class="markdown-body">
<h2 id="about">About</h2>
<p>勉強ログとか、書き捨てコードとか、いろいろ。</p>
      </div>
    </div>
    <div id="turing-machine-contents" class="contents">
      <div class="markdown-body">
<h2 id="チューリングマシン">チューリングマシン</h2>
<p>Practical なプログラミング言語はいろいろやってきたけど、そういえば計算機科学的な素養があまりないな、とふと思ったので、 基礎（？）に立ちもどって、チューリングマシンの勉強をしてみる。</p>
<h3 id="形式的定義">形式的定義</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo>,</mo><mi>Γ</mi><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>Σ</mi><mo>,</mo><mi>δ</mi><mo>,</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><mi>H</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
M = (Q, \Gamma, a_0, \Sigma, \delta, q_0, H)
</annotation></semantics></math></p>
<p>ただし</p>
<table>
<colgroup>
<col width="55%" />
<col width="44%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math></td>
<td align="left"><strong>状態</strong> (<em>state</em>) の集合</td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></td>
<td align="left"><strong>記号</strong> (<em>symbol</em>) の集合</td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo>∈</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">a_0 \in \Gamma</annotation></semantics></math></td>
<td align="left"><strong>空白記号</strong> (<em>blank symbol</em>)</td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>⊆</mo><mi>Γ</mi><mo>\</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\Sigma \subseteq \Gamma \setminus \{a_0\}</annotation></semantics></math></td>
<td align="left"><strong>入力記号</strong> (<em>input symbol</em>) の集合</td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo accent="false">→</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo>×</mo><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}</annotation></semantics></math></td>
<td align="left"><strong>遷移関数</strong> (<em>transition function</em>) と呼ばれる部分関数</td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0 \in Q</annotation></semantics></math></td>
<td align="left"><strong>初期状態</strong> (<em>initial state</em>)</td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">H \subseteq Q</annotation></semantics></math></td>
<td align="left"><strong>受理状態</strong> (<em>accept state</em>) の集合</td>
</tr>
</tbody>
</table>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false" form="prefix">|</mo><mi>Q</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">n = |Q|</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo stretchy="false" form="prefix">|</mo><mi>Γ</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">m = |\Gamma|</annotation></semantics></math> として、 <strong><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>状態<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>記号チューリングマシン</strong> (<em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-state <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>-symbol Turing machine</em>) とか、 <strong>(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>)チューリングマシン</strong> (<em>(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>) Turing Machine</em>) とかいう。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mo>⋯</mo><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>,</mo><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><mo>⋯</mo><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,\cdots,a_n,b_1,\cdots,b_n</annotation></semantics></math> を記号とし、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mi>i</mi></msub><annotation encoding="application/x-tex">q_i</annotation></semantics></math> を状態とするとき、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mi>q</mi><mi>i</mi></msub><msub><mi>b</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1\cdots a_nq_ib_1\cdots b_n</annotation></semantics></math> を M の様相という。</p>
<p><strong>例</strong>: 様相 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mi>q</mi><mi>i</mi></msub><msub><mi>b</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1\cdots a_nq_ib_1\cdots b_n</annotation></semantics></math> で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo>,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_i,b_1)=(q_{i+1},a_{n+1},R)</annotation></semantics></math> ならば、そのつぎの様相は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>q</mi><mi>i</mi></msub><msub><mi>b</mi><mn>2</mn></msub><mo>⋯</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1\cdots a_na_{n+1}q_ib_2\cdots b_n</annotation></semantics></math> となる。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mi>i</mi></msub><annotation encoding="application/x-tex">q_i</annotation></semantics></math> のすぐ右隣 (この場合は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mn>1</mn></msub><annotation encoding="application/x-tex">b_1</annotation></semantics></math>) を第2引数としてとって、 2番めの戻り値の (この場合は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">a_{n+1}</annotation></semantics></math>) で置きかえる。</p>
<ul>
<li>様相 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mi>q</mi><mi>i</mi></msub><msub><mi>b</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>b</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1\cdots a_nq_ib_1\cdots b_n</annotation></semantics></math> のとき、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>∈</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">q_i\in H</annotation></semantics></math> ならば <strong>受理</strong> (<em>accept</em>)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo>,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_i,b_1)</annotation></semantics></math> が定義されていない場合は <strong>拒否</strong> (<em>reject</em>)</li>
</ul>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math> を空白記号、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mo>⋯</mo><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,\cdots,a_n</annotation></semantics></math> を入力記号、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>0</mn></msub><annotation encoding="application/x-tex">q_0</annotation></semantics></math> を初期状態とするとき、 TM は様相 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋯</mo><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><msub><mi>q</mi><mn>0</mn></msub><msub><mi>a</mi><mn>1</mn></msub><mo>⋯</mo><msub><mi>a</mi><mi>n</mi></msub><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>⋯</mo></mrow><annotation encoding="application/x-tex">\cdots a_0a_0q_0a_1\cdots a_na_0a_0\cdots</annotation></semantics></math> から開始して、受理または拒否して停止するまで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> に従った動作を続ける。</p>
<h3 id="チューリングマシンとは">チューリングマシンとは</h3>
<p>チューリングマシンは、プログラマの言葉でいうところのプログラムにあたる。</p>
<p><em>Note</em>: チューリング完全でないプログラムがあるように(例: <code>fn () =&gt; 42</code> のような定数関数)、 チューリング完全でないチューリングマシンもある。</p>
<h3 id="万能チューリングマシンとは">万能チューリングマシンとは</h3>
<p>万能チューリングマシンはチューリングマシンの1種であり、チューリング完全なチューリングマシンのこと。</p>
<p>プログラマの言葉でいえば、チューリング完全なプログラムのことを万能チューリングマシンという。</p>
<p><strong>例</strong>: (チューリング完全な言語の) インタプリタ</p>
<h3 id="複雑性クラスとか">複雑性クラスとか</h3>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> を文字列の集合とすると、(ある具体的なチューリングマシンが) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> に属する文字列をすべて受理するとき、 (そのある具体的なチューリングマシンは) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> を <strong>認識</strong> (<em>recognize</em>) するという。 言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>ℒ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{L}</annotation></semantics></math> は言語の集合である。 すべての言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∈</mo><mstyle mathvariant="script"><mi>ℒ</mi></mstyle></mrow><annotation encoding="application/x-tex">L \in \mathcal{L}</annotation></semantics></math> について、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> を認識する具体的なチューリングマシンが存在するとき、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>ℒ</mi></mstyle><annotation encoding="application/x-tex">\mathcal{L}</annotation></semantics></math> を (一般的な意味での) チューリングマシンが認識する言語のクラスとかいう。</p>
<ul>
<li>帰納的可算言語 (<strong>RE</strong>): チューリングマシンが受理して停止するか、無限ループする言語。 チューリングマシンはすべての帰納的可算言語を認識できる (チューリングマシンが認識する言語のクラス)。</li>
<li>帰納言語 (<strong>R</strong>): チューリングマシンが受理または拒否して停止する言語。</li>
</ul>
<h3 id="計算可能関数">計算可能関数</h3>
<p>数学の関数をコンピュータで実装しようとなると、どうしたってアルゴリズムが必要になる。 そこでアルゴリズムの存在する関数を計算可能関数と呼ぶことにしよう、というのがチャーチ＝チューリングのテーゼ。</p>
<p>ではアルゴリズムとはなにか？ というと、チューリングマシンで定義することができて、かつ、定義域の入力に対しては常に停止し、正しい結果を返すもの (たとえば素数を引数にとる関数に素数でない数を渡した場合、停止しないかもしれないし、停止しても結果が正しいとは限らないが、 素数を渡した場合は常に停止するし、結果もやはり正しいもの)。</p>
<p>もうちょっと厳密な定義もあるらしいんだけど、理解するのも説明するのも難しいので、まあ大雑把にはそんな感じだと思う。</p>
<p>このへんは興味があるんだけど、まだあんまり理解できていない……。</p>
<h3 id="多テープチューリングマシンとかramチューリングマシン">多テープチューリングマシンとかRAMチューリングマシン</h3>
<p>テープの数をひとつではなくふたつにしたり、ランダムアクセスできるようにしたり、 非決定計算をできるようにチューリングマシンを拡張することもできる。 ただし、このように拡張しても等価であることが示されている。 もちろん現実にはランダムアクセスできたほうが計算効率がよいとかはあるだろうが、計算可能性という意味では等価である、という意味。</p>
<h3 id="チューリングマシンの参考実装">チューリングマシンの参考実装</h3>
<pre class="sml"><code>signature TURING_MACHINE = sig
  datatype shift = L | R
  eqtype state
  eqtype symbol
  eqtype input_symbol
  val blank : symbol
  val transition : state * symbol -&gt; (state * symbol * shift) option
  val initialState : state
  val acceptStates : state list

  (* utility functions *)
  val symbol : input_symbol -&gt; symbol
end

signature TM = sig
  include TURING_MACHINE
  val accept : input_symbol list -&gt; bool
end

functor TM(M: TURING_MACHINE) : TM = struct
  open M

  val CHUNK_SIZE = 256

  fun extend tape i = let
  in
    if !i - 1 &lt; 0 then (
      tape := Array.tabulate(Array.length (!tape) + CHUNK_SIZE, fn j =&gt;
        if j &lt; CHUNK_SIZE then
          M.blank
        else
          Array.sub(!tape, j - CHUNK_SIZE))
    ; i := !i + CHUNK_SIZE
    ) else
      ()
  ; if !i + 1 &gt;= Array.length (!tape) then (
      tape := Array.tabulate(Array.length (!tape) + CHUNK_SIZE, fn j =&gt;
        if j &lt; Array.length (!tape) then
          Array.sub(!tape, j)
        else
          M.blank)
    ) else
      ()
  end

  fun accept(input) = let
    val tape = ref (Array.fromList (map M.symbol input))
    val q = ref M.initialState
    val i = ref 0
    val reject = ref false
  in
    while not (!reject) andalso not (List.exists (fn q&#39; =&gt; !q = q&#39;) M.acceptStates) do let
      val () = extend tape i
      val a = Array.sub(!tape, !i)
    in
      case M.transition(!q, a) of
        NONE =&gt;
          reject := true
      | SOME (q&#39;, a&#39;, m) =&gt; let
        val offset = case m of M.L =&gt; ~1 | M.R =&gt; 1
      in
        Array.update(!tape, !i, a&#39;)
      ; q := q&#39;
      ; i := !i + offset
      end
    end
  ; not (!reject)
  end
end</code></pre>
<h3 id="チューリングマシンの例">チューリングマシンの例</h3>
<p><a href="https://en.wikipedia.org/wiki/Turing_machine_examples" class="uri">https://en.wikipedia.org/wiki/Turing_machine_examples</a> にいろいろある。</p>
<h4 id="ウルフラムの2状態3記号チューリングマシン">ウルフラムの2状態3記号チューリングマシン</h4>
<p>チューリング完全性が証明されている、かなりシンプルなチューリングマシン。</p>
<p>参考: <a href="https://en.wikipedia.org/wiki/Wolfram%27s_2-state_3-symbol_Turing_machine">https://en.wikipedia.org/wiki/Wolfram%27s_2-state_3-symbol_Turing_machine</a></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>q</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mi>δ</mi><mo>,</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><mo>∅</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
M = (\{q_0, q_1\}, \{a_0,a_1,a_2\}, a_0, \{a_1, a_2\}, \delta, q_0, \emptyset)
</annotation></semantics></math></p>
<p>遷移関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> は状態遷移表で書くことが多いようだ。</p>
<table>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>0</mn></msub><annotation encoding="application/x-tex">q_0</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_1,a_1,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_0,a_2,L)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>1</mn></msub><annotation encoding="application/x-tex">a_1</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_0,a_2,L)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_1,a_2,R)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>2</mn></msub><annotation encoding="application/x-tex">a_2</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_0,a_1,L)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_0,a_0,R)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<p>あまり見ないが、プログラマには関数表記のほうがわかりやすいかもしれない。</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo accent="false">→</mo><mi>Q</mi><mo>×</mo><mi>Γ</mi><mo>×</mo><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_0, a_0) = (q_1,a_1,R)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_0, a_1) = (q_0,a_2,L)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_0, a_2) = (q_0,a_1,L)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_1, a_0) = (q_0,a_2,L)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_1, a_1) = (q_1,a_2,R)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(q_1, a_2) = (q_0,a_0,R)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<h5 id="参考実装">参考実装</h5>
<pre class="sml"><code>signature WOLFRAM_2_3 = sig
  include TM
  val A1 : input_symbol
  val A2 : input_symbol
end

local
  structure Wolfram_2_3 = struct
    datatype shift = L | R
    datatype state = Q0 | Q1
    datatype symbol = A0 | A1&#39; | A2&#39;
    datatype input_symbol = A1 | A2

    val blank = A0

    fun transition(Q0, A0) = SOME (Q1, A1&#39;, R)
      | transition(Q0, A1&#39;) = SOME (Q0, A2&#39;, L)
      | transition(Q0, A2&#39;) = SOME (Q0, A1&#39;, L)
      | transition(Q1, A0) = SOME (Q0, A2&#39;, L)
      | transition(Q1, A1&#39;) = SOME (Q1, A2&#39;, R)
      | transition(Q1, A2&#39;) = SOME (Q0, A0, R)

    val initialState = Q0

    val acceptStates = nil

    (* utility functions *)
    fun symbol A1 = A1&#39;
      | symbol A2 = A2&#39;
  end

  structure TMWolfram_2_3 = TM(Wolfram_2_3)
in
  structure Wolfram_2_3 :&gt; WOLFRAM_2_3 = struct
    open Wolfram_2_3
    val accept = TMWolfram_2_3.accept
  end
end</code></pre>
<h4 id="を-2n-個並べた文字列を受理するチューリングマシン">0 を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math> 個並べた文字列を受理するチューリングマシン</h4>
<p>チューリングマシンのテキストでは、なんでかわからないけど最初にこれを例示することが多いらしい。 なのでここにも書いておく。</p>
<p>たとえば &quot;0&quot; (0 を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>0</mn></msup><annotation encoding="application/x-tex">2^0</annotation></semantics></math> 個並べた文字列) や &quot;00&quot; (0 を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>1</mn></msup><annotation encoding="application/x-tex">2^1</annotation></semantics></math> 個並べた文字列)、 &quot;0000&quot; (0 を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>2</mn></msup><annotation encoding="application/x-tex">2^2</annotation></semantics></math> 個並べた文字列) や &quot;00000000&quot; (0 を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>3</mn></msup><annotation encoding="application/x-tex">2^3</annotation></semantics></math> 個並べた文字列) だったら受理して停止し、 そうでなければ拒否して停止するかもしくは停止しないチューリングマシンを考える。</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>q</mi><mn>2</mn></msub><mo>,</mo><msub><mi>q</mi><mn>3</mn></msub><mo>,</mo><msub><mi>q</mi><mn>4</mn></msub><mo>,</mo><msub><mi>q</mi><mn>5</mn></msub><mo>,</mo><msub><mi>q</mi><mn>6</mn></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mi>δ</mi><mo>,</mo><msub><mi>q</mi><mn>0</mn></msub><mo>,</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>q</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
M = (\{q_0, q_1, q_2, q_3, q_4, q_5, q_6\}, \{a_0, a_1, 0\}, a_0, \{0\}, \delta, q_0, \{q_1\})
</annotation></semantics></math></p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">start</th>
<th align="left">accept</th>
<th align="left">reject</th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>0</mn></msub><annotation encoding="application/x-tex">q_0</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>1</mn></msub><annotation encoding="application/x-tex">q_1</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>2</mn></msub><annotation encoding="application/x-tex">q_2</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>3</mn></msub><annotation encoding="application/x-tex">q_3</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>4</mn></msub><annotation encoding="application/x-tex">q_4</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>5</mn></msub><annotation encoding="application/x-tex">q_5</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mn>6</mn></msub><annotation encoding="application/x-tex">q_6</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>0</mn></msub><annotation encoding="application/x-tex">a_0</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_2,a_0,R)</annotation></semantics></math></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_1,a_0,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>6</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_6,a_0,L)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_2,a_0,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>3</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_3,a_0,R)</annotation></semantics></math></td>
</tr>
<tr class="odd">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>1</mn></msub><annotation encoding="application/x-tex">a_1</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_2,a_1,R)</annotation></semantics></math></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>3</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_3,a_1,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>4</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_4,a_1,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>5</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_5,a_1,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>6</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_6,a_1,L)</annotation></semantics></math></td>
</tr>
<tr class="even">
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>3</mn></msub><mo>,</mo><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_3,a_0,R)</annotation></semantics></math></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>4</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_4,a_1,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>5</mn></msub><mo>,</mo><mn>0</mn><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_5,0,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>4</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_4,a_1,R)</annotation></semantics></math></td>
<td align="left"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>q</mi><mn>6</mn></msub><mo>,</mo><mn>0</mn><mo>,</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(q_6,0,L)</annotation></semantics></math></td>
</tr>
</tbody>
</table>
<h5 id="参考実装-1">参考実装</h5>
<pre class="sml"><code>signature EXAMPLE0 = sig
  include TM
  val O : input_symbol
  val parse : string -&gt; input_symbol list option
end

local
  structure Example0 = struct
    datatype shift = L | R
    datatype state = Q0 | Q1 | Q2 | Q3 | Q4 | Q5 | Q6
    datatype symbol = A0 | A1 | O&#39;
    datatype input_symbol = O

    val blank = A0

    fun transition(Q0, A0) = SOME (Q2, A0, R)
      | transition(Q0, A1) = SOME (Q2, A1, R)
      | transition(Q0, O&#39;) = SOME (Q3, A0, R)
      | transition(Q1, _) = NONE
      | transition(Q2, _) = NONE
      | transition(Q3, A0) = SOME (Q1, A0, R)
      | transition(Q3, A1) = SOME (Q3, A1, R)
      | transition(Q3, O&#39;) = SOME (Q4, A1, R)
      | transition(Q4, A0) = SOME (Q6, A0, L)
      | transition(Q4, A1) = SOME (Q4, A1, R)
      | transition(Q4, O&#39;) = SOME (Q5, O&#39;, R)
      | transition(Q5, A0) = SOME (Q2, A0, R)
      | transition(Q5, A1) = SOME (Q5, A1, R)
      | transition(Q5, O&#39;) = SOME (Q4, A1, R)
      | transition(Q6, A0) = SOME (Q3, A0, R)
      | transition(Q6, A1) = SOME (Q6, A1, L)
      | transition(Q6, O&#39;) = SOME (Q6, O&#39;, L)

    val initialState = Q0

    val acceptStates = [Q1]

    (* utility functions *)
    fun symbol O = O&#39;
  end

  structure TMExample0 = TM(Example0)
in
  structure Example0 :&gt; EXAMPLE0 = struct
    open Example0
    val accept = TMExample0.accept

    fun parse s = let
      val zeros = String.explode s
    in
      if List.all (fn zero =&gt; zero = #&quot;0&quot;) zeros then
        SOME (map (fn _ =&gt; O) zeros)
      else
        NONE
    end
  end
end

val () = let
  val SOME zero0 = Example0.parse &quot;&quot;
  val SOME zero1 = Example0.parse &quot;0&quot;
  val SOME zero2 = Example0.parse &quot;00&quot;
  val SOME zero3 = Example0.parse &quot;000&quot;
  val SOME zero4 = Example0.parse &quot;0000&quot;
  val SOME zero5 = Example0.parse &quot;00000&quot;
  val SOME zero6 = Example0.parse &quot;000000&quot;
  val SOME zero7 = Example0.parse &quot;0000000&quot;
  val SOME zero8 = Example0.parse &quot;00000000&quot;
in
  if Example0.accept zero0 then
    print &quot;accept zero0\n&quot;
  else
    print &quot;reject zero0\n&quot;
; if Example0.accept zero1 then
    print &quot;accept zero1\n&quot;
  else
    print &quot;reject zero1\n&quot;
; if Example0.accept zero2 then
    print &quot;accept zero2\n&quot;
  else
    print &quot;reject zero2\n&quot;
; if Example0.accept zero3 then
    print &quot;accept zero3\n&quot;
  else
    print &quot;reject zero3\n&quot;
; if Example0.accept zero4 then
    print &quot;accept zero4\n&quot;
  else
    print &quot;reject zero4\n&quot;
; if Example0.accept zero5 then
    print &quot;accept zero5\n&quot;
  else
    print &quot;reject zero5\n&quot;
; if Example0.accept zero6 then
    print &quot;accept zero6\n&quot;
  else
    print &quot;reject zero6\n&quot;
; if Example0.accept zero7 then
    print &quot;accept zero7\n&quot;
  else
    print &quot;reject zero7\n&quot;
; if Example0.accept zero8 then
    print &quot;accept zero8\n&quot;
  else
    print &quot;reject zero8\n&quot;
end</code></pre>
<pre><code>$ mlton turing-machine.sml
$ ./turing-machine
reject zero0
accept zero1
accept zero2
reject zero3
accept zero4
reject zero5
reject zero6
reject zero7
accept zero8</code></pre>
      </div>
    </div>
    <div id="language-contents" class="contents">
      <div class="markdown-body">
<h2 id="草案-計算量を型で表す言語">草案: 計算量を型で表す言語</h2>
<p>なんか計算量を型で表すプログラミング言語を考えている。 その草案。</p>
<h3 id="動機">動機</h3>
<p>関数型言語は強力な静的型システムを備えている。 しかし、計算量についてはやや無頓着なところがある。 たとえば、配列のランダムアクセスは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> でリストのシーケンシャルアクセスは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> だが、 ML の型システムでは、両者とも同じ型となってしまう:</p>
<pre class="sml"><code>Array.sub : &#39;a array * int -&gt; &#39;a
List.nth : &#39;a list * int -&gt; &#39;a</code></pre>
<p>これはモジュールのシグネチャに、計算量に関する制約を記述できないことを意味する:</p>
<pre><code>signature RANDOM_ACCESS = sig
  type &#39;a t
  (* It should be O(1) *)
  val at : &#39;a t * int -&gt; &#39;a
end

(* Good implementation *)
structure ArrayRandomAccess :&gt; RANDOM_ACCESS = struct
  type &#39;a t = &#39;a array
  val at = Array.sub
end

(* Bad implementation *)
structure ListRandomAccess :&gt; RANDOM_ACCESS = struct
  type &#39;a t = &#39;a list
  val at = List.nth
end</code></pre>
<p>そうではなく、シグネチャに計算量についての情報も含めたい。 これは単に計算量に関する制約を与えるのみならず、ドキュメンテーションの観点からも有用である:</p>
<pre><code>signature RANDOM_ACCESS = sig
  type &#39;a t
  val at : &#39;a t * int -&gt; &#39;a where O(1)
end

(* Compiler accepts this code *)
structure ArrayRandomAccess :&gt; RANDOM_ACCESS = struct
  type &#39;a t = &#39;a array
  val at = Array.sub
end

(* Compiler rejects this code *)
structure ListRandomAccess :&gt; RANDOM_ACCESS = struct
  type &#39;a t = &#39;a list
  val at = List.nth
end</code></pre>
<h3 id="停止性問題">停止性問題</h3>
<p>まずこの言語において、計算量を推論することは可能か、ということを検討しておきたい。</p>
<p>そこでまず第一に検討すべきことは停止性問題であろう。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> はもちろん <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> や <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>!</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math> でさえも、基本的には有限の時間で停止する計算量である。 停止しない計算の計算量というのはあまり聞きなれないが、 計算量を型で表すとなると、停止しない計算にも型をつけられなければならない。 そこで停止しない計算量の計算量を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mo>∞</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\infty)</annotation></semantics></math> で表すことにする。 ここでもし、ある関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> とその実引数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> が与えられたときに <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math> の計算量を返す関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">C(f,x)</annotation></semantics></math> があったとすると、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mo>∞</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">C(f,x)=O(\infty)</annotation></semantics></math> かどうかを調べれば停止性を判定できてしまうので、このような <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> は存在しないことがわかる。</p>
<h3 id="推論を諦めればチューリング完全な体系に計算量の検査を導入できるのか">推論を諦めればチューリング完全な体系に計算量の検査を導入できるのか</h3>
<p>これもかなり難しいと言わざるを得ない。 人工的な例で恐縮だが、関数の宣言部で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mo>∞</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\infty)</annotation></semantics></math> を明示したところで、部分式が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> なのか <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mo>∞</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\infty)</annotation></semantics></math> なのかを導出する必要はどうしてもあり、 やはり停止性問題の影響を受けることになる。</p>
<pre class="sml"><code>fun f(n : int) : int where O(n) = let
  val i = ref 0
in
  while !i &lt; n do (i := !i + 1)
; 0
end

fun g(n : int) : int where O(inf) = (
  while true do ()
; 0
)</code></pre>
<h3 id="チューリング完全でない体系なら可能なのか">チューリング完全でない体系なら可能なのか</h3>
<p>停止性問題があるので、チューリング完全な体系の計算量を推論することは諦めたほうがよさそうである。 ではチューリング完全でない体系なら可能なのか？ なんとなく &quot;できそう&quot; な気はするが、確信はない。</p>
<p>たとえば、 <code>for i = n do M</code> という構文を導入し、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,n)</annotation></semantics></math> の区間を繰りかえすとする。 その場合、明らかに <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> ということがわかる。</p>
<pre class="sml"><code>fun f(n : int) : int where O(n) = (
  for i = n do
    ()
; 0
)</code></pre>
<p>さらにいえば、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>:</mo><mi>T</mi><mspace width="0.222em"></mspace><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mspace width="0.222em"></mspace><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">M : T\ where\ O(x)</annotation></semantics></math> ならば <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mspace width="0.222em"></mspace><mi>i</mi><mspace width="0.222em"></mspace><mo>=</mo><mspace width="0.222em"></mspace><mi>n</mi><mspace width="0.222em"></mspace><mi>d</mi><mi>o</mi><mspace width="0.222em"></mspace><mi>M</mi><mo>:</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mspace width="0.222em"></mspace><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mspace width="0.222em"></mspace><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>×</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">for\ i\ =\ n\ do\ M : unit\ where\ O(n\times x)</annotation></semantics></math> とすることで、2重ループには <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n\times n)=O(n^2)</annotation></semantics></math> という型をつけることもできる。 <code>()</code> などは <code>() : T where O(1)</code> とすればいい。</p>
<pre class="sml"><code>(* .. where O(n^2) .. は .. where O(n*n) .. の略記とする *)
fun f(n : int) : int where O(n^2) = (
  for i = n do
    for j = n do
      ()
; 0
)</code></pre>
<h3 id="整数以外のデータ構造">整数以外のデータ構造</h3>
<p>これまでは整数に対する計算量しか扱ってこなかった。 より柔軟な表現をするためには、ユーザ定義型の長さが <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> ならば <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math> といった表現をすることが必要になるだろう。</p>
<p>では、どのようなユーザ定義型に対して長さをつける必要があるのか？ それは、イテレーション可能なデータ型に対して、要するに、配列や再帰的な構造などである。</p>
<p>まず、組や和などの非再帰的な構造に関しては長さを知る必要はない。 なぜならイテレーションすることができないためである。</p>
<p>配列に関しては、すこし巧妙な型つけが必要になるだろう。 <code>[x1, .., xn] : (n, 'a) array</code> のような型をつけることにすると、 <code>Array.map</code> の型はつぎのようになる:</p>
<pre class="sml"><code>Array.map : (&#39;a -&gt; &#39;b) -&gt; (n, &#39;a) array -&gt; (n, &#39;b) array where O(n)</code></pre>
<p>再帰的なデータ型に関して。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>X</mi><mo>.</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu X.T</annotation></semantics></math> というような表現を、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>.</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu X(n).T</annotation></semantics></math> のように拡張する。 これは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>.</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu X(n).T</annotation></semantics></math> の長さが <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> という意味である。 再帰型の fold/unfold の操作は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>.</mo><mi>T</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mi>μ</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>m</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>.</mo><mi>T</mi><mo>/</mo><mi>X</mi><mo stretchy="false" form="postfix">]</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu X(n).T=[\mu X(m_{ij}).T/X]T</annotation></semantics></math> という感じになる。 さらにここで、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">m_{ij}</annotation></semantics></math> は新たにフレッシュな変数を生成してそれぞれ代入し、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>m</mi><mn>11</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>m</mi><mrow><mn>1</mn><mi>l</mi></mrow></msub><mo>+</mo><mn>1</mn><mo>=</mo><mo>⋯</mo><mo>=</mo><msub><mi>m</mi><mrow><mi>k</mi><mn>1</mn></mrow></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>m</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=m_11+\cdots+m_{1l}+1=\cdots=m_{k1}+\cdots+m_{kl}+1</annotation></semantics></math> という感じの関係式を導入する。 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> は和やバリアントの分岐の数、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> は組やレコードの要素の数となる。 (このへんは形式化するとなるとたいへんそう)</p>
<p>また、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>.</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu X(n).T</annotation></semantics></math> という表現において、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math> が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math> の左側に現れてはならない、という制限も加える。 これを加えなければ容易にチューリング完全になり、停止性問題につきあたる。</p>
<p>パターンマッチに関して。 2分木のように、パターンマッチすることで徐々に処理対象のデータを減らすことができる構造の場合、 より複雑な型つけが必要になってくるだろう。 しかし、まだこのへんは詰められていない……。</p>
<h3 id="依存型との関係">依存型との関係</h3>
<p>値に依存する型を書けるという意味で、これはすこし依存型と似ている。 ただ範囲チェックなどに使うわけではないので、おそらく &quot;具体的な&quot; 値を知る必要はないんでは、という気がしている。 たとえばこの型つけでは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math> も <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><msup><mn>2</mn><mn>64</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(2^64)</annotation></semantics></math> も同じ型になる。</p>
<p>そもそも依存型の型推論は決定不能なので、その関係で計算量の推論もできない可能性はある。 とはいえ、それを言うと System F だって決定不能なわけで、 ML みたいな制限をかけて、実用的な落としどころを見つけることで推論ができることもある、みたいな例もある。</p>
<p>たぶん、計算量の記述のみに使えるという制限を依存型に課した体系になりそうとかなんとか。 そういう制限をした体系の性質について考えるのは意義があることだと思っている。</p>
<h3 id="先行研究について">先行研究について</h3>
<p>なんかこういう研究ありそうだけど、よく知らない……。 調べてみたけどなんかよくわからなかった（ひどい）。</p>
<p>くわしいひとがいたら教えてください。</p>
      </div>
    </div>
  </div>
</div>
