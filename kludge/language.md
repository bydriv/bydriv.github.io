## 草案: 計算量を型で表す言語

なんか計算量を型で表すプログラミング言語を考えている。
その草案。

### 動機

関数型言語は強力な静的型システムを備えている。
しかし、計算量についてはやや無頓着なところがある。
たとえば、配列のランダムアクセスは $O(1)$ でリストのシーケンシャルアクセスは $O(n)$ だが、
ML の型システムでは、両者とも同じ型となってしまう:

```sml
Array.sub : 'a array * int -> 'a
List.nth : 'a list * int -> 'a
```

これはモジュールのシグネチャに、計算量に関する制約を記述できないことを意味する:

```
signature RANDOM_ACCESS = sig
  type 'a t
  (* It should be O(1) *)
  val at : 'a t * int -> 'a
end

(* Good implementation *)
structure ArrayRandomAccess :> RANDOM_ACCESS = struct
  type 'a t = 'a array
  val at = Array.sub
end

(* Bad implementation *)
structure ListRandomAccess :> RANDOM_ACCESS = struct
  type 'a t = 'a list
  val at = List.nth
end
```

そうではなく、シグネチャに計算量についての情報も含めたい。
これは単に計算量に関する制約を与えるのみならず、ドキュメンテーションの観点からも有用である:

```
signature RANDOM_ACCESS = sig
  type 'a t
  val at : 'a t * int -> 'a where O(1)
end

(* Compiler accepts this code *)
structure ArrayRandomAccess :> RANDOM_ACCESS = struct
  type 'a t = 'a array
  val at = Array.sub
end

(* Compiler rejects this code *)
structure ListRandomAccess :> RANDOM_ACCESS = struct
  type 'a t = 'a list
  val at = List.nth
end
```

### 停止性問題

まずこの言語において、計算量を推論することは可能か、ということを検討しておきたい。

そこでまず第一に検討すべきことは停止性問題であろう。
$O(1)$ はもちろん $O(n)$ や $O(n!)$ でさえも、基本的には有限の時間で停止する計算量である。
停止しない計算の計算量というのはあまり聞きなれないが、
計算量を型で表すとなると、停止しない計算にも型をつけられなければならない。
そこで停止しない計算量の計算量を $O(\infty)$ で表すことにする。
ここでもし、ある関数 $f$ とその実引数 $x$ が与えられたときに $f(x)$ の計算量を返す関数 $C(f,x)$ があったとすると、
$C(f,x)=O(\infty)$ かどうかを調べれば停止性を判定できてしまうので、このような $C$ は存在しないことがわかる。

### 推論を諦めればチューリング完全な体系に計算量の検査を導入できるのか

これもかなり難しいと言わざるを得ない。
人工的な例で恐縮だが、関数の宣言部で $O(n)$ と $O(\infty)$ を明示したところで、部分式が $O(n)$ なのか $O(\infty)$ なのかを導出する必要はどうしてもあり、
やはり停止性問題の影響を受けることになる。

```sml
fun f(n : int) : int where O(n) = let
  val i = ref 0
in
  while !i < n do (i := !i + 1)
; 0
end

fun g(n : int) : int where O(inf) = (
  while true do ()
; 0
)
```

### チューリング完全でない体系なら可能なのか

停止性問題があるので、チューリング完全な体系の計算量を推論することは諦めたほうがよさそうである。
ではチューリング完全でない体系なら可能なのか？
なんとなく "できそう" な気はするが、確信はない。

たとえば、 `for i = n do M` という構文を導入し、 $[0,n)$ の区間を繰りかえすとする。
その場合、明らかに $O(n)$ ということがわかる。

```sml
fun f(n : int) : int where O(n) = (
  for i = n do
    ()
; 0
)
```

さらにいえば、 $M : T\ where\ O(x)$ ならば $for\ i\ =\ n\ do\ M : unit\ where\ O(n\times x)$ とすることで、2重ループには
$O(n\times n)=O(n^2)$ という型をつけることもできる。
`()` などは `() : T where O(1)` とすればいい。

```sml
(* .. where O(n^2) .. は .. where O(n*n) .. の略記とする *)
fun f(n : int) : int where O(n^2) = (
  for i = n do
    for j = n do
      ()
; 0
)
```

### 整数以外のデータ構造

これまでは整数に対する計算量しか扱ってこなかった。
より柔軟な表現をするためには、ユーザ定義型の長さが $n$ ならば $O(n)$ といった表現をすることが必要になるだろう。

では、どのようなユーザ定義型に対して長さをつける必要があるのか？
それは、イテレーション可能なデータ型に対して、要するに、配列や再帰的な構造などである。

まず、組や和などの非再帰的な構造に関しては長さを知る必要はない。
なぜならイテレーションすることができないためである。

配列に関しては、すこし巧妙な型つけが必要になるだろう。
`[x1, .., xn] : (n, 'a) array` のような型をつけることにすると、 `Array.map` の型はつぎのようになる:

```sml
Array.map : ('a -> 'b) -> (n, 'a) array -> (n, 'b) array where O(n)
```

再帰的なデータ型に関して。
$\mu X.T$ というような表現を、 $\mu X(n).T$ のように拡張する。
これは $\mu X(n).T$ の長さが $n$ という意味である。
再帰型の fold/unfold の操作は $\mu X(n).T=[\mu X(m_{ij}).T/X]T$ という感じになる。
さらにここで、 $m_{ij}$ は新たにフレッシュな変数を生成してそれぞれ代入し、
$n=m_11+\cdots+m_{1l}+1=\cdots=m_{k1}+\cdots+m_{kl}+1$ という感じの関係式を導入する。
$i$ は和やバリアントの分岐の数、 $j$ は組やレコードの要素の数となる。
(このへんは形式化するとなるとたいへんそう)

また、 $\mu X(n).T$ という表現において、 $X$ が $\rightarrow$ の左側に現れてはならない、という制限も加える。
これを加えなければ容易にチューリング完全になり、停止性問題につきあたる。

パターンマッチに関して。
2分木のように、パターンマッチすることで徐々に処理対象のデータを減らすことができる構造の場合、
より複雑な型つけが必要になってくるだろう。
しかし、まだこのへんは詰められていない……。

### 依存型との関係

値に依存する型を書けるという意味で、これはすこし依存型と似ている。
ただ範囲チェックなどに使うわけではないので、おそらく "具体的な" 値を知る必要はないんでは、という気がしている。
たとえばこの型つけでは $O(1)$ も $O(2^64)$ も同じ型になる。

そもそも依存型の型推論は決定不能なので、その関係で計算量の推論もできない可能性はある。
とはいえ、それを言うと System F だって決定不能なわけで、 ML みたいな制限をかけて、実用的な落としどころを見つけることで推論ができることもある、みたいな例もある。

たぶん、計算量の記述のみに使えるという制限を依存型に課した体系になりそうとかなんとか。
そういう制限をした体系の性質について考えるのは意義があることだと思っている。

### 先行研究について

なんかこういう研究ありそうだけど、よく知らない……。
調べてみたけどなんかよくわからなかった（ひどい）。

くわしいひとがいたら教えてください。
