%module Data.Anne.Parsing %where

%start anne

%{
import qualified Data.Anne.Defn as Defn

type Anne = Defn.Anne
type Data = Defn.Data
type Datum = Defn.Datum
type Atom = Defn.Atom
type List = Defn.List
type Document = Defn.Document

type LBRACKET = (Defn.Pos, String)
type RBRACKET = (Defn.Pos, String)
type LBRACE = (Defn.Pos, String)
type RBRACE = (Defn.Pos, String)
type BLANK = (Defn.Pos, String)
type TEXT = (Defn.Pos, String)
type RAW1 = (Defn.Pos, Char, String)
type RAWN = (Defn.Pos, String, String)
%}

%%

def rule anne :=
  data
| data BLANK anne

def rule data :=
| datum data

def rule datum :=
  atom
| list
| document

def rule atom :=
  TEXT
| RAW1
| RAWN

def rule list :=
  LBRACKET data RBRACKET

def rule document :=
  LBRACE anne RBRACE

%%

semanticActions :: Monad m => SemanticActions m
semanticActions = SemanticActions
  { anne_implies_data = \ds ->
      return (Defn.Anne [Right ds])
  , anne_implies_data_BLANK_anne = \ds (p, s) (Defn.Anne dss) ->
      return (Defn.Anne (Right ds:Left (Defn.Blank p s):dss))
  , data_implies =
      return (Defn.Data [])
  , data_implies_datum_data = \d (Defn.Data ds) ->
      return (Defn.Data (d:ds))
  , datum_implies_atom = \a ->
      return (Defn.AtomDatum a)
  , datum_implies_list = \l ->
      return (Defn.ListDatum l)
  , datum_implies_document = \d ->
      return (Defn.DocumentDatum d)
  , atom_implies_TEXT = \(p, s) ->
      return (Defn.Text p s)
  , atom_implies_RAW1 = \(p, k, s) ->
      return (Defn.Raw1 p k s)
  , atom_implies_RAWN = \(p, k, s) ->
      return (Defn.RawN p k s)
  , list_implies_LBRACKET_data_RBRACKET = \((l, _), _) ds ((_, r), _) ->
      return (Defn.List (l, r) ds)
  , document_implies_LBRACE_anne_RBRACE = \((l, _), _) anne ((_, r), _) ->
      return (Defn.Document (l, r) anne) }
