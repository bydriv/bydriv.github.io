%module Data.Anne.Parsing %where

%start anne

%{
import qualified Data.Anne.Defn as Defn

type Anne = Defn.Anne
type Document = Defn.Document
type Paragraph = Defn.Paragraph
type Data = Defn.Data
type Datum = Defn.Datum
type Atom = Defn.Atom
type List = Defn.List
type Wrapper = Defn.Wrapper

type LBRACKET = (Defn.Pos, String)
type RBRACKET = (Defn.Pos, String)
type LBRACE = (Defn.Pos, String)
type RBRACE = (Defn.Pos, String)
type BLANK = (Defn.Pos, String)
type TEXT = (Defn.Pos, String)
type RAW1 = (Defn.Pos, Char, String)
type RAWN = (Defn.Pos, String, String)
%}

%%

def rule anne :=
  document

def rule document :=
  paragraph
| paragraph BLANK document

def rule paragraph :=
  data

def rule data :=
| datum data

def rule datum :=
  atom
| list
| wrapper

def rule atom :=
  TEXT
| RAW1
| RAWN

def rule list :=
  LBRACKET data RBRACKET

def rule wrapper :=
  LBRACE document RBRACE

%%

semanticActions :: Monad m => SemanticActions m
semanticActions = SemanticActions
  { anne_implies_document = \d ->
      return (Defn.Anne d)
  , document_implies_paragraph = \par ->
      return (Defn.Document [Right par])
  , document_implies_paragraph_BLANK_document = \par (p, s) (Defn.Document dss) ->
      return (Defn.Document (Right par:Left (Defn.Blank p s):dss))
  , paragraph_implies_data = \ds ->
      return (Defn.Paragraph ds)
  , data_implies =
      return (Defn.Data [])
  , data_implies_datum_data = \d (Defn.Data ds) ->
      return (Defn.Data (d:ds))
  , datum_implies_atom = \a ->
      return (Defn.AtomDatum a)
  , datum_implies_list = \l ->
      return (Defn.ListDatum l)
  , datum_implies_wrapper = \w ->
      return (Defn.WrapperDatum w)
  , atom_implies_TEXT = \(p, s) ->
      return (Defn.Text p s)
  , atom_implies_RAW1 = \(p, k, s) ->
      return (Defn.Raw1 p k s)
  , atom_implies_RAWN = \(p, k, s) ->
      return (Defn.RawN p k s)
  , list_implies_LBRACKET_data_RBRACKET = \((l, _), _) ds ((_, r), _) ->
      return (Defn.List (l, r) ds)
  , wrapper_implies_LBRACE_document_RBRACE = \((l, _), _) d ((_, r), _) ->
      return (Defn.Wrapper (l, r) d) }
