%module Data.Anne.Lexing %where

%{
import qualified Control.Monad.State as State
import qualified Data.Anne.Parsing   as Parsing
%}

%%

case (Initial,                                                                                ['\n'|'\r']+) => saBlank
case (Initial, '<' [^'<']                                                                                 ) => saRaw1
case (Initial, "<<" [^'\n'|'\r']+                                                               '\r'?'\n'?) => saRawN
case (Initial, '['                                                                                        ) => saLeftBracket
case (Initial, ']'                                                                                        ) => saRightBracket
case (Initial, ( [^'\n'|'\r'|'<'|'['|'\\'|']'] | ('\\' (['\n'|'\r'|'<'|'['|'\\'|']']|"\r\n")))* '\r'?'\n'?) => saText
case (Middle , '<' [^'<']                                                                                 ) => saRaw1
case (Middle , "<<" [^'\n'|'\r']+                                                               '\r'?'\n'?) => saRawN
case (Middle , '['                                                                                        ) => saLeftBracket
case (Middle , ']'                                                                                        ) => saRightBracket
case (Middle , ( [^'\n'|'\r'|'<'|'['|'\\'|']'] | ('\\' .) )*                                    '\r'?'\n'?) => saText
case (Raw1   , .                                                                                          ) => saRaw1Char
case (RawN   , [^'\n'|'\r']*                                                                    '\r'?'\n'?) => saRawNLine

%%

type S = (Int, Int, Int, String, [String])

withPosition :: (Int -> Int -> String -> Lexing (State.State S) (Maybe Parsing.Token)) -> String -> Lexing (State.State S) (Maybe Parsing.Token)
withPosition f yytext = do
  let n = length yytext
  (pos, bufP, bufN, k, buf) <- MonadTrans.lift State.get
  MonadTrans.lift $ State.put (pos + n, bufP, bufN, k, buf)
  f pos n yytext

clearBuffer :: Lexing (State.State S) ()
clearBuffer = do
  (pos, _, _, _, _) <- MonadTrans.lift State.get
  MonadTrans.lift $ State.put (pos, 0, 0, "", [])

setBuffer :: Int -> Int -> String -> Lexing (State.State S) ()
setBuffer p n k = do
  (pos, _, _, _, _) <- MonadTrans.lift State.get
  MonadTrans.lift $ State.put (pos, p, n, k, [])

appendToBuffer :: Int -> String -> Lexing (State.State S) ()
appendToBuffer n s = do
  (pos, bufP, bufN, k, buf) <- MonadTrans.lift State.get
  MonadTrans.lift $ State.put (pos, bufP, bufN + n, k, s:buf)

flushBuffer :: Lexing (State.State S) String
flushBuffer = do
  (_, _, _, _, buf) <- MonadTrans.lift State.get
  clearBuffer
  return $ concat $ reverse buf

unescape :: String -> String
unescape [] = []
unescape ('\\':c:s) = c : unescape s
unescape (c:s) = c : unescape s

semanticActions :: SemanticActions (State.State S) (Maybe Parsing.Token)
semanticActions = SemanticActions
  { saBlank = withPosition $ \p n yytext ->
      return $ Just $ Parsing.BLANK ((p, p + n), yytext)
  , saRaw1 = withPosition $ \p n yytext -> do
      yybegin Raw1
      setBuffer p n (tail yytext)
      return Nothing
  , saRawN = withPosition $ \p n yytext -> do
      yybegin RawN
      setBuffer p n (drop 2 yytext)
      return Nothing
  , saLeftBracket = withPosition $ \p n yytext -> do
      yybegin Middle
      return $ Just $ Parsing.LBRACKET ((p, p + n), yytext)
  , saRightBracket = withPosition $ \p n yytext -> do
      yybegin Middle
      return $ Just $ Parsing.RBRACKET ((p, p + n), yytext)
  , saText = withPosition $ \p n yytext -> do
      yybegin Initial
      return $ Just $ Parsing.TEXT ((p, p + n), unescape yytext)
  , saRaw1Char = withPosition $ \_ n yytext -> do
      (_, bufP, bufN, k, _) <- MonadTrans.lift State.get

      if yytext == k then do
        s <- flushBuffer
        yybegin Initial
        return $ Just $ Parsing.RAW1 ((bufP, bufP + bufN + n), head k, s)
      else do
        appendToBuffer n yytext
        return Nothing
  , saRawNLine = withPosition $ \_ n yytext -> do
      (_, bufP, bufN, k, _) <- MonadTrans.lift State.get

      if yytext == k then do
        s <- flushBuffer
        yybegin Initial
        return $ Just $ Parsing.RAWN ((bufP, bufP + bufN + n), k, s)
      else do
        appendToBuffer n yytext
        return Nothing }
