<!DOCTYPE html>

<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/etc/site/style.css">
  <title>bydriv.github.io</title>
  <meta property="og:url" content="https://bydriv.github.io/misc/lemma/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="bydriv.github.io" />
  <meta property="og:description" content="Lemma" />
  <meta property="og:site_name" content="bydriv.github.io" />
  <meta property="og:image" content="https://bydriv.github.io/etc/site/thumbnail.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <script type="text/javascript" src="/etc/site/kt.js"></script>
</head>

<div class="navigation"><!--
--><div class="left"><!--
--><a class="section" href="/">&#x221A;</a><!--
--><a class="section" href="/illustration">&#x1F3A8;</a><!--
--><a class="section" href="/photo">&#x1F4F7;</a><!--
--><a class="section" href="/literature">&#x1F516;</a><!--
--><a class="section" href="/world">&#x1F4BD;</a><!--
--><a class="section" href="/comic">&#x1F4AD;</a><!--
--><a class="section" href="/vr">&#x1F9E9;</a><!--
--><a class="section" href="/misc">&#x1F4C1;</a><!--
--></div>&nbsp;<!--
--><div class="right"><!--
--><a class="holoio section" href="#holoio">&#x22EF;</a><!--
--></div><!--
--></div><!--
--><div id="holoio">
<div class="navigation"><!--
--><div class="left"><!--
-->&nbsp;</div>&nbsp;<!--
--><div class="right"><!--
--><a class="section" href="#">&#x2573;</a><!--
--></div><!--
--></div>

<div class="kt-month-calendar" data-today="true"></div>
</div>

<article>
<h1 id="lemma">Lemma</h1>
<p>補題ライブラリ。</p>
<h2 id="metric.v">Metric.v</h2>
<pre><code>Require Import ZArith.
Open Scope Z.

Axiom A : Set.
Axiom f : A -&gt; A -&gt; Z.

Axiom A1 : forall x y : A, x = y &lt;-&gt; f x y = 0.
Axiom A2 : forall x y : A, f x y = -(f y x).
Axiom A3 : forall x y z : A, Z.abs (f x y) + Z.abs (f y z) &gt;= Z.abs (f x z).
Axiom A4 : forall x y z : A, f x y &gt;= 0 /\ f y z &gt;= 0 -&gt; f x z &gt;= 0.

Lemma L1 : forall i j : Z, i &gt;= 0 -&gt; j &gt;= 0 -&gt; i + j &gt;= 0.
Proof.
  intros i j P Q.
  omega.
Qed.

Lemma L2 : forall i : Z, i &gt;= 0 -&gt; i = Z.abs i.
Proof.
  intros i P.
  assert (i &gt;= 0 -&gt; i = i). congruence.
  assert (i &lt;= 0 -&gt; i = -i). omega.
  apply (Zabs_ind (fun j =&gt; i = j) i H H0).
Qed.

Lemma L3 : forall x y : A, f x y &lt;= 0 &lt;-&gt; f y x &gt;= 0.
Proof.
  intros x y. rewrite A2. omega.
Qed.

Lemma L4 : forall i j : Z, i - j = i + (- j).
Proof.
  intros i j.
  omega.
Qed.

Lemma L5 : forall i j : Z, i + (- - j) = i + j.
Proof.
  intros i j.
  omega.
Qed.

Theorem T1 : forall x y z : A, f x y &gt;= 0 -&gt; f y z &gt;= 0 -&gt; f x y + f y z &gt;= f x z /\ f x z &gt;= 0.
Proof.
  intros x y z P Q.
  assert (f x z &gt;= 0). apply (A4 x y z (conj P Q)).
  assert (f x y = Z.abs (f x y)). apply (L2 (f x y) P).
  assert (f y z = Z.abs (f y z)). apply (L2 (f y z) Q).
  assert (f x z = Z.abs (f x z)). apply (L2 (f x z) H).
  rewrite H0.
  rewrite H1.
  rewrite H2.
  split.
  apply (A3 x y z).
  omega.
Qed.

Theorem T2 : forall x y z : A, f x y &lt;= 0 -&gt; f y z &lt;= 0 -&gt; f x y + f y z &lt;= f x z /\ f x z &lt;= 0.
Proof.
  intros x y z P Q.
  assert (f z y + f y x &gt;= f z x /\ f z x &gt;= 0).
  apply (T1 z y x (proj1 (L3 y z) Q) (proj1 (L3 x y) P)).
  rewrite (A2 x y).
  rewrite (A2 y z).
  rewrite (A2 x z).
  omega.
Qed.

Theorem T3 : forall x y z : A, f x y &gt;= 0 -&gt; f z y &lt;= 0 -&gt; f x z &gt;= 0.
Proof.
  intros x y z P Q.
  apply (A4 x y z (conj P (proj1 (L3 z y) Q))).
Qed.

Theorem T4 : forall x y z : A, f x y &lt;= 0 -&gt; f z y &gt;= 0 -&gt; f z x &gt;= 0.
Proof.
  intros x y z P Q.
  apply (A4 z y x (conj Q (proj1 (L3 x y) P))).
Qed.

Theorem T5 : forall x y z : A, f x y &lt;= 0 -&gt; f y z &lt;= 0 -&gt; f x z &lt;= 0.
Proof.
  intros x y z P Q.
  apply (L3 x z).
  apply (A4 z y x (conj (proj1 (L3 y z) Q) (proj1 (L3 x y) P))).
Qed.

Theorem T6 : forall x y z : A, f x y &gt;= 0 -&gt; f z y &lt;= 0 -&gt; f z x &lt;= 0.
Proof.
  intros x y z P Q.
  apply (T5 z y x Q (proj2 (L3 y x) P)).
Qed.

Theorem T7 : forall x y z : A, f x y &lt;= 0 -&gt; f z y &gt;= 0 -&gt; f x z &lt;= 0.
Proof.
  intros x y z P Q.
  apply (T5 x y z P (proj2 (L3 y z) Q)).
Qed.</code></pre>
<h2 id="lemma.metric">Lemma.Metric</h2>
<pre><code>module Lemma.Metric
  ( Metric(metric), distance
  , MetricOrd, LeftSign, RightSign, LeftDistance, RightDistance
  , metricOrd, leftSign, rightSign, leftDistance, rightDistance ) where

import qualified Data.Int   as Int
import qualified Data.Ratio as Ratio
import qualified Data.Word  as Word

--------------------------------------------------------------------------------
--  SYNOPSIS
--------------------------------------------------------------------------------
--  | The Metric class
--  ----------------------------------------------------------------------------
--  | x == y                              &lt;==&gt; metric x y == 0
--  | metric x y                           ==  negate (metric y x)
--  | abs (metric x y) + abs (metric y z)  &gt;=  abs (metric x z)
--  | metric x y &gt;= 0 AND metric y z &gt;= 0  ==&gt; metric x z &gt;= 0
--------------------------------------------------------------------------------

class Metric a where
  metric :: a -&gt; a -&gt; Rational

distance :: Metric a =&gt; a -&gt; a -&gt; Rational
distance x x&#39; =
  abs (metric x x&#39;)

--------------------------------------------------------------------------------

newtype MetricOrd a =
    MetricOrd a
  deriving (Read, Show)

metricOrd :: Metric a =&gt; a -&gt; MetricOrd a
metricOrd =
  MetricOrd

--------------------------------------------------------------------------------

instance Metric a =&gt; Eq (MetricOrd a) where
  MetricOrd x == MetricOrd x&#39; =
    metric x x&#39; == 0

instance Metric a =&gt; Ord (MetricOrd a) where
  compare (MetricOrd x) (MetricOrd x&#39;) =
    compare (metric x x&#39;) 0

--------------------------------------------------------------------------------

newtype LeftSign a b =
    LeftSign (a, b)
  deriving (Read, Show)

newtype RightSign a b =
    RightSign (a, b)
  deriving (Read, Show)

newtype LeftDistance a b =
    LeftDistance (a, b)
  deriving (Read, Show)

newtype RightDistance a b =
    RightDistance (a, b)
  deriving (Read, Show)

leftSign :: (Metric a, Metric b) =&gt; a -&gt; b -&gt; LeftSign a b
leftSign x y =
  LeftSign (x, y)

rightSign :: (Metric a, Metric b) =&gt; a -&gt; b -&gt; RightSign a b
rightSign x y =
  RightSign (x, y)

leftDistance :: (Metric a, Metric b) =&gt; a -&gt; b -&gt; LeftDistance a b
leftDistance x y =
  LeftDistance (x, y)

rightDistance :: (Metric a, Metric b) =&gt; a -&gt; b -&gt; RightDistance a b
rightDistance x y =
  RightDistance (x, y)

--------------------------------------------------------------------------------

instance (Metric a, Metric b) =&gt; Metric (LeftSign a b) where
  metric (LeftSign (x, y)) (LeftSign (x&#39;, y&#39;)) =
      if p /= 0 then
        signum p * (abs p + abs q)
      else
        signum q * (abs p + abs q)
    where
      p = metric x x&#39;
      q = metric y y&#39;

instance (Metric a, Metric b) =&gt; Metric (RightSign a b) where
  metric (RightSign (x, y)) (RightSign (x&#39;, y&#39;)) =
      if q /= 0 then
        signum q * (abs p + abs q)
      else
        signum p * (abs p + abs q)
    where
      p = metric x x&#39;
      q = metric y y&#39;

instance (Metric a, Metric b) =&gt; Metric (LeftDistance a b) where
  metric (LeftDistance (x, y)) (LeftDistance (x&#39;, y&#39;)) =
      if p&#39; /= 0 then
        signum p&#39; * (abs p&#39; + abs q&#39;)
      else
        signum q&#39; * (abs p&#39; + abs q&#39;)
    where
      p = metric x x&#39;
      q = metric y y&#39;
      p&#39; = p + q
      q&#39; = p - q

instance (Metric a, Metric b) =&gt; Metric (RightDistance a b) where
  metric (RightDistance (x, y)) (RightDistance (x&#39;, y&#39;)) =
      if q&#39; /= 0 then
        signum q&#39; * (abs p&#39; + abs q&#39;)
      else
        signum p&#39; * (abs p&#39; + abs q&#39;)
    where
      p = metric x x&#39;
      q = metric y y&#39;
      p&#39; = p + q
      q&#39; = p - q

--------------------------------------------------------------------------------

instance (Metric a, Metric b) =&gt; Eq (LeftSign a b) where
  xy == xy&#39; =
    MetricOrd xy == MetricOrd xy&#39;

instance (Metric a, Metric b) =&gt; Eq (RightSign a b) where
  xy == xy&#39; =
    MetricOrd xy == MetricOrd xy&#39;

instance (Metric a, Metric b) =&gt; Eq (LeftDistance a b) where
  xy == xy&#39; =
    MetricOrd xy == MetricOrd xy&#39;

instance (Metric a, Metric b) =&gt; Eq (RightDistance a b) where
  xy == xy&#39; =
    MetricOrd xy == MetricOrd xy&#39;

--------------------------------------------------------------------------------

instance (Metric a, Metric b) =&gt; Ord (LeftSign a b) where
  compare xy xy&#39; =
    compare (MetricOrd xy) (MetricOrd xy&#39;)

instance (Metric a, Metric b) =&gt; Ord (RightSign a b) where
  compare xy xy&#39; =
    compare (MetricOrd xy) (MetricOrd xy&#39;)

instance (Metric a, Metric b) =&gt; Ord (LeftDistance a b) where
  compare xy xy&#39; =
    compare (MetricOrd xy) (MetricOrd xy&#39;)

instance (Metric a, Metric b) =&gt; Ord (RightDistance a b) where
  compare xy xy&#39; =
    compare (MetricOrd xy) (MetricOrd xy&#39;)

--------------------------------------------------------------------------------

instance (Metric a, Metric b) =&gt; Metric (a, b) where
  metric (x, y) (x&#39;, y&#39;) =
    metric (leftSign x y) (leftSign x&#39; y&#39;)

instance (Metric a, Metric b) =&gt; Metric (Either a b) where
  metric (Left x) (Left x&#39;) =
    metric x x&#39;
  metric (Right y) (Right y&#39;) =
    metric y y&#39;
  metric (Left _) (Right _) =
    -1
  metric (Right _) (Left _) =
    1

instance (Metric a) =&gt; Metric (Maybe a) where
  metric Nothing Nothing =
    0
  metric Nothing (Just _) =
    -1
  metric (Just _) Nothing =
    1
  metric (Just x) (Just x&#39;) =
    metric x x&#39;

instance (Metric a) =&gt; Metric [a] where
  metric [] [] =
    0
  metric [] _ =
    -1
  metric _ [] =
    1
  metric (x : xs) (x&#39; : xs&#39;) =
    metric (leftSign x xs) (leftSign x&#39; xs&#39;)

--------------------------------------------------------------------------------

instance Metric Integer where
  metric i j =
    toRational i - toRational j

instance Integral a =&gt; Metric (Ratio.Ratio a) where
  metric p q =
    toRational p - toRational q

--------------------------------------------------------------------------------

instance Metric Int.Int8 where
  metric i j =
    toRational i - toRational j

instance Metric Int.Int16 where
  metric i j =
    toRational i - toRational j

instance Metric Int.Int32 where
  metric i j =
    toRational i - toRational j

instance Metric Int.Int64 where
  metric i j =
    toRational i - toRational j

--------------------------------------------------------------------------------

instance Metric Word.Word8 where
  metric n m =
    toRational n - toRational m

instance Metric Word.Word16 where
  metric n m =
    toRational n - toRational m

instance Metric Word.Word32 where
  metric n m =
    toRational n - toRational m

instance Metric Word.Word64 where
  metric n m =
    toRational n - toRational m

--------------------------------------------------------------------------------

instance Metric () where
  metric () () =
    0

instance Metric Bool where
  metric x y =
    case compare x y of
      LT -&gt;
        -1
      EQ -&gt;
        0
      GT -&gt;
        1

instance Metric Ordering where
  metric x y =
    case compare x y of
      LT -&gt;
        negate (toRational (length [x .. y]) - 1)
      EQ -&gt;
        0
      GT -&gt;
        toRational (length [y .. x]) - 1

instance Metric Char where
  metric c c&#39; =
    toRational (fromEnum c) - toRational (fromEnum c&#39;)

instance Metric Int where
  metric i j =
    toRational i - toRational j

instance Metric Float where
  metric x y =
    toRational x - toRational y

instance Metric Double where
  metric x y =
    toRational x - toRational y</code></pre>
<h2 id="lemma.graph">Lemma.Graph</h2>
<pre><code>module Lemma.Graph
  ( Graph
  , empty, singleton, insert, member, between
  , isLinearlyOrdered, lookupLeft, lookupRight, searchLeft, searchRight
  , lookupLeftQuarter, lookupRightQuarter
  , rotateLeft, rotateRight ) where

import qualified Lemma.Metric as Metric

data Graph a b =
    Leaf
  | Branch a b (Graph a b) (Graph a b)
  deriving (Read, Show)

empty :: Graph a b
empty =
  Leaf

singleton :: a -&gt; b -&gt; Graph a b
singleton x y =
  Branch x y Leaf Leaf

insert :: (Metric.Metric a, Metric.Metric b) =&gt; a -&gt; b -&gt; Graph a b -&gt; Graph a b
insert x y Leaf =
  singleton x y
insert x y (Branch x&#39; y&#39; a b) =
  case compare (Metric.leftDistance x y) (Metric.leftDistance x&#39; y&#39;) of
    LT -&gt;
      Branch x&#39; y&#39; (insert x y a) b
    EQ -&gt;
      Branch x&#39; y&#39; a b
    GT -&gt;
      Branch x&#39; y&#39; a (insert x y b)

member :: (Metric.Metric a, Metric.Metric b) =&gt; a -&gt; b -&gt; Graph a b -&gt; Bool
member _ _ Leaf =
  False
member x y (Branch x&#39; y&#39; a b) =
  case compare (Metric.leftDistance x y) (Metric.leftDistance x&#39; y&#39;) of
    LT -&gt;
      member x y a
    EQ -&gt;
      True
    GT -&gt;
      member x y b

between ::
  (Metric.Metric a, Metric.Metric b) =&gt;
    (a, b) -&gt; (a, b) -&gt; Graph a b -&gt; [(a, b)]
between _ _ Leaf =
  []
between (x1, y1) (x2, y2) (Branch x y a b) =
  case
    ( compare (Metric.leftDistance x1 y1) (Metric.leftDistance x y)
    , compare (Metric.leftDistance x2 y2) (Metric.leftDistance x y) )
  of
    (GT, LT) -&gt;
      []
    (_, LT) -&gt;
      between (x1, y1) (x2, y2) a
    (GT, _) -&gt;
      between (x1, y1) (x2, y2) b
    (_, _) -&gt;
      between (x1, y1) (x2, y2) a ++ (x, y) : between (x1, y1) (x2, y2) b

--------------------------------------------------------------------------------
--  Operations for Linearly Ordered Sets
--------------------------------------------------------------------------------

isLinearlyOrdered :: (Metric.Metric a, Metric.Metric b) =&gt; Graph a b -&gt; Bool
isLinearlyOrdered Leaf =
  True
isLinearlyOrdered (Branch x y a b) =
  case (a, b) of
    (Leaf, Leaf) -&gt;
      True
    (Leaf, Branch x1 y1 _ _) -&gt;
      signum (Metric.metric x x1) &lt; 0 &amp;&amp; signum (Metric.metric y y1) &lt; 0
        &amp;&amp; isLinearlyOrdered b
    (Branch x1 y1 _ _, Leaf) -&gt;
      signum (Metric.metric x x1) &gt;= 0 &amp;&amp; signum (Metric.metric y y1) &gt;= 0
        &amp;&amp; isLinearlyOrdered a
    (Branch x1 y1 _ _, Branch x2 y2 _ _) -&gt;
      signum (Metric.metric x x1) &gt;= 0 &amp;&amp; signum (Metric.metric y y1) &gt;= 0
        &amp;&amp; signum (Metric.metric x x2) &lt; 0 &amp;&amp; signum (Metric.metric y y2) &lt; 0
        &amp;&amp; isLinearlyOrdered a &amp;&amp; isLinearlyOrdered b

--  O(log(n)) | isLinearlyOrdered(G)
lookupLeft :: Metric.Metric a =&gt; a -&gt; Graph a b -&gt; Maybe b
lookupLeft _ Leaf =
  Nothing
lookupLeft x (Branch x&#39; y&#39; a b) =
  case compare (Metric.metric x x&#39;) 0 of
    LT -&gt;
      lookupLeft x a
    EQ -&gt;
      Just y&#39;
    GT -&gt;
      lookupLeft x b

--  O(log(n)) | isLinearlyOrdered(G)
lookupRight :: Metric.Metric b =&gt; b -&gt; Graph a b -&gt; Maybe a
lookupRight _ Leaf =
  Nothing
lookupRight y (Branch x&#39; y&#39; a b) =
  case compare (Metric.metric y y&#39;) 0 of
    LT -&gt;
      lookupRight y a
    EQ -&gt;
      Just x&#39;
    GT -&gt;
      lookupRight y b

searchLeft :: Metric.Metric a =&gt; a -&gt; Graph a b -&gt; [b]
searchLeft _ Leaf =
  []
searchLeft x (Branch x&#39; y&#39; a b) =
  case compare (Metric.metric x x&#39;) 0 of
    LT -&gt;
      searchLeft x a
    EQ -&gt;
      y&#39; : searchLeft x a
    GT -&gt;
      searchLeft x b

searchRight :: Metric.Metric b =&gt; b -&gt; Graph a b -&gt; [a]
searchRight _ Leaf =
  []
searchRight y (Branch x&#39; y&#39; a b) =
  case compare (Metric.metric y y&#39;) 0 of
    LT -&gt;
      searchRight y a
    EQ -&gt;
      x&#39; : searchRight y a
    GT -&gt;
      searchRight y b

--------------------------------------------------------------------------------
--  3/4 logarithmic searching
--------------------------------------------------------------------------------

-- O(log(n)) | 75% elements
-- O(n)      | 25% outliers
lookupLeftQuarter :: Metric.Metric a =&gt; a -&gt; Graph a b -&gt; Maybe b
lookupLeftQuarter _ Leaf =
  Nothing
lookupLeftQuarter x (Branch x&#39; y&#39; a b) =
  case compare (Metric.metric x x&#39;) 0 of
    LT -&gt;
      case lookupLeftQuarter x a of
        Nothing -&gt;
          lookupLeftQuarter x b
        Just y -&gt;
          Just y
    EQ -&gt;
      Just y&#39;
    GT -&gt;
      case lookupLeftQuarter x b of
        Nothing -&gt;
          lookupLeftQuarter x a
        Just y -&gt;
          Just y

-- O(log(n)) | 75% elements
-- O(n)      | 25% outliers
lookupRightQuarter :: Metric.Metric b =&gt; b -&gt; Graph a b -&gt; Maybe a
lookupRightQuarter _ Leaf =
  Nothing
lookupRightQuarter y (Branch x&#39; y&#39; a b) =
  case compare (Metric.metric y y&#39;) 0 of
    LT -&gt;
      case lookupRightQuarter y a of
        Nothing -&gt;
          lookupRightQuarter y b
        Just x -&gt;
          Just x
    EQ -&gt;
      Just x&#39;
    GT -&gt;
      case lookupRightQuarter y b of
        Nothing -&gt;
          lookupRightQuarter y a
        Just x -&gt;
          Just x

--------------------------------------------------------------------------------

rotateLeft :: Graph a b -&gt; Graph a b
rotateLeft Leaf =
  Leaf
rotateLeft (Branch x y a Leaf) =
  Branch x y a Leaf
rotateLeft (Branch x y a (Branch x&#39; y&#39; b c)) =
  Branch x&#39; y&#39; (Branch x y a b) c

rotateRight :: Graph a b -&gt; Graph a b
rotateRight Leaf =
  Leaf
rotateRight (Branch x y Leaf b) =
  Branch x y Leaf b
rotateRight (Branch x y (Branch x&#39; y&#39; a b) c) =
  Branch x&#39; y&#39; a (Branch x y b c)</code></pre>
</article>
