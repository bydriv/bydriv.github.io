<!DOCTYPE html>

<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" href="/etc/site/style.css">
  <title>bydriv.github.io</title>
  <meta property="og:url" content="https://bydriv.github.io/misc/injection/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="bydriv.github.io" />
  <meta property="og:description" content="Injection" />
  <meta property="og:site_name" content="bydriv.github.io" />
  <meta property="og:image" content="https://bydriv.github.io/etc/site/thumbnail.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <script type="text/javascript" src="/etc/site/kt.js"></script>
</head>

<div class="navigation"><!--
--><div class="left"><!--
--><a class="section" href="/">&#x221A;</a><!--
--><a class="section" href="/blog">&#x1F4DD;</a><!--
--><a class="section" href="/illustration">&#x1F3A8;</a><!--
--><a class="section" href="/photo">&#x1F4F7;</a><!--
--><a class="section" href="/literature">&#x1F516;</a><!--
--><a class="section" href="/world">&#x1F4BD;</a><!--
--><a class="section" href="/comic">&#x1F4AD;</a><!--
--><a class="section" href="/vr">&#x1F9E9;</a><!--
--><a class="section" href="/misc">&#x1F4C1;</a><!--
--></div>&nbsp;<!--
--><div class="right"><!--
--><a class="holoio section" href="#holoio">&#x22EF;</a><!--
--></div><!--
--></div><!--
--><div id="holoio">
<div class="navigation"><!--
--><div class="left"><!--
-->&nbsp;</div>&nbsp;<!--
--><div class="right"><!--
--><a class="section" href="#">&#x2573;</a><!--
--></div><!--
--></div>

<div class="kt-month-calendar" data-today="true"></div>
</div>

<article>
<h1 id="data.injection">Data.Injection</h1>
<p><strong>単射</strong> (<em>injection</em>) の Haskell 実装</p>
<ul>
<li><a href="Injection.hs" class="uri">Injection.hs</a></li>
</ul>
<pre><code>module Data.Injection where

import qualified Control.Monad as Monad
import qualified Data.List     as List
import qualified Data.Maybe    as Maybe

class Injection f where
  empty :: (Ord a, Ord b) =&gt; f a b
  insert :: (Ord a, Ord b) =&gt; a -&gt; b -&gt; f a b -&gt; f a b
  lookupLeft :: (Ord a, Ord b) =&gt; a -&gt; f a b -&gt; Maybe b
  lookupRight :: (Ord a, Ord b) =&gt; b -&gt; f a b -&gt; Maybe a

singleton :: (Injection f, Ord a, Ord b) =&gt; a -&gt; b -&gt; f a b
singleton x y = insert x y empty

memberLeft :: (Injection f, Ord a, Ord b) =&gt; a -&gt; f a b -&gt; Bool
memberLeft x f = Maybe.isJust (lookupLeft x f)

memberRight :: (Injection f, Ord a, Ord b) =&gt; b -&gt; f a b -&gt; Bool
memberRight y f = Maybe.isJust (lookupRight y f)

fromAList :: (Injection f, Ord a, Ord b) =&gt; [(a, b)] -&gt; f a b
fromAList = foldr (\(x, y) -&gt; insert x y) empty

newtype AList a b =
    AList [(a, b)]
  deriving (Eq, Ord, Read, Show)

instance Injection AList where
  empty = AList []
  insert x y (AList l) = AList ((x, y) : l)
  lookupLeft x (AList l) = fmap snd $ List.find (\(x&#39;, _) -&gt; x == x&#39;) l
  lookupRight y (AList l) = fmap fst $ List.find (\(_, y&#39;) -&gt; y == y&#39;) l

data Quadtree a b =
    Empty
  | Branch (a, b) (Quadtree a b) (Quadtree a b) (Quadtree a b) (Quadtree a b)
  deriving (Eq, Ord, Read, Show)

newtype ReadQuadtree a b =
    ReadQuadtree (Quadtree a b)
  deriving (Eq, Ord, Read, Show)

newtype WriteQuadtree a b =
    WriteQuadtree (Quadtree a b)
  deriving (Eq, Ord, Read, Show)

instance Injection ReadQuadtree where
  empty = ReadQuadtree Empty

  insert x y (ReadQuadtree Empty) = ReadQuadtree (Branch (x, y) Empty Empty Empty Empty)
  insert x y (ReadQuadtree (Branch (x&#39;, y&#39;) t1 t2 t3 t4))
    | x == x&#39; || y == y&#39; = ReadQuadtree (Branch (x, y) t1 t2 t3 t4)
    | otherwise =
        let
          ReadQuadtree t1&#39; = if x &lt; x&#39; then insert x y (ReadQuadtree t1) else ReadQuadtree t1
          ReadQuadtree t2&#39; = if x &gt; x&#39; then insert x y (ReadQuadtree t2) else ReadQuadtree t2
          ReadQuadtree t3&#39; = if y &lt; y&#39; then insert x y (ReadQuadtree t3) else ReadQuadtree t3
          ReadQuadtree t4&#39; = if y &gt; y&#39; then insert x y (ReadQuadtree t4) else ReadQuadtree t4
        in
          ReadQuadtree (Branch (x&#39;, y&#39;) t1&#39; t2&#39; t3&#39; t4&#39;)

  lookupLeft _ (ReadQuadtree Empty) = Nothing
  lookupLeft x (ReadQuadtree (Branch (x&#39;, y) t1 t2 t3 t4))
    | x == x&#39; = Just y
    | x &lt; x&#39; = lookupLeft x (ReadQuadtree t1)
    | x &gt; x&#39; = lookupLeft x (ReadQuadtree t2)

  lookupRight _ (ReadQuadtree Empty) = Nothing
  lookupRight y (ReadQuadtree (Branch (x, y&#39;) t1 t2 t3 t4))
    | y == y&#39; = Just x
    | y &lt; y&#39; = lookupRight y (ReadQuadtree t3)
    | y &gt; y&#39; = lookupRight y (ReadQuadtree t4)

instance Injection WriteQuadtree where
  empty = WriteQuadtree Empty

  insert x y (WriteQuadtree Empty) = WriteQuadtree (Branch (x, y) Empty Empty Empty Empty)
  insert x y (WriteQuadtree (Branch (x&#39;, y&#39;) t1 t2 t3 t4))
    | x == x&#39; || y == y&#39; = WriteQuadtree (Branch (x, y) t1 t2 t3 t4)
    | otherwise =
        let
          WriteQuadtree t1&#39; = if x &lt; x&#39; &amp;&amp; y &lt; y&#39; then insert x y (WriteQuadtree t1) else WriteQuadtree t1
          WriteQuadtree t2&#39; = if x &lt; x&#39; &amp;&amp; y &gt; y&#39; then insert x y (WriteQuadtree t2) else WriteQuadtree t2
          WriteQuadtree t3&#39; = if x &gt; x&#39; &amp;&amp; y &lt; y&#39; then insert x y (WriteQuadtree t3) else WriteQuadtree t3
          WriteQuadtree t4&#39; = if x &gt; x&#39; &amp;&amp; y &gt; y&#39; then insert x y (WriteQuadtree t4) else WriteQuadtree t4
        in
          WriteQuadtree (Branch (x&#39;, y&#39;) t1&#39; t2&#39; t3&#39; t4&#39;)

  lookupLeft _ (WriteQuadtree Empty) = Nothing
  lookupLeft x (WriteQuadtree (Branch (x&#39;, y) t1 t2 t3 t4))
    | x == x&#39; = Just y
    | x &lt; x&#39; = Monad.mplus (lookupLeft x (WriteQuadtree t1)) (lookupLeft x (WriteQuadtree t2))
    | x &gt; x&#39; = Monad.mplus (lookupLeft x (WriteQuadtree t3)) (lookupLeft x (WriteQuadtree t4))

  lookupRight _ (WriteQuadtree Empty) = Nothing
  lookupRight y (WriteQuadtree (Branch (x, y&#39;) t1 t2 t3 t4))
    | y == y&#39; = Just x
    | y &lt; y&#39; = Monad.mplus (lookupRight y (WriteQuadtree t1)) (lookupRight y (WriteQuadtree t3))
    | y &gt; y&#39; = Monad.mplus (lookupRight y (WriteQuadtree t2)) (lookupRight y (WriteQuadtree t4))</code></pre>
</article>
