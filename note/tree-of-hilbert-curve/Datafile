@title
ヒルベルト曲線を用いた二分探索木について

@header
ヒルベルト曲線を用いた二分探索木について

@nav
..
.
appendix

@chapter
はしがき

　二分探索木は線型の（一次元の直線状に並べることができる）データを扱うのに適した
データ構造で、たとえば Map a b といった構造を実装するためにもちいられます。
さて Map a b は一般に a から b を探索することは効率的にできる一方、 b から a を
探索することは不得手です。これは (a, b) といった二次元のデータというものは、
一般に並べると直線ではなく表になるためです。そこで二次元の表を一次元の直線に
変換してから扱う方法として空間充填曲線を用いるものがあります。ここではヒルベルト
曲線を扱う方法を紹介します。

@right
(2021-10-31)

@chapter
ヒルベルト曲線とは

　空間充填曲線と呼ばれる曲線のひとつで、たとえば以下のような形状をしています。
またこれが再帰的に繰り返されます。

<img src="hilbert.svg">

　プログラムでは以下のように平面上の座標 (x, y) をとって直線上の座標に写す関数として定義
することができます。

@curve.hs

　たとえば上記の例ですと、つぎのように一辺が 2⁴ の長さの正方形の座標に順序を与えることができます。

@code
> let xys :: [(Int, Int)]
|     xys = map fst $ List.sortBy (\a b -> compare (snd a) (snd b))
|             [((x, y), curve 4 (x % 16) (y % 16)) | x <- [0..15], y <- [0..15]]
|
> print xys
[(0,0),(1,0),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3),(3,3),(3,2),(3,1),(2,1),(2,0),(3,0),(4,0),(4,1),(5,1),(5,0),(6,0),(7,0),(7,1),(6,1),(6,2),(7,2),(7,3),(6,3),(5,3),(5,2),(4,2),(4,3),(4,4),(4,5),(5,5),(5,4),(6,4),(7,4),(7,5),(6,5),(6,6),(7,6),(7,7),(6,7),(5,7),(5,6),(4,6),(4,7),(3,7),(2,7),(2,6),(3,6),(3,5),(3,4),(2,4),(2,5),(1,5),(1,4),(0,4),(0,5),(0,6),(1,6),(1,7),(0,7),(0,8),(0,9),(1,9),(1,8),(2,8),(3,8),(3,9),(2,9),(2,10),(3,10),(3,11),(2,11),(1,11),(1,10),(0,10),(0,11),(0,12),(1,12),(1,13),(0,13),(0,14),(0,15),(1,15),(1,14),(2,14),(2,15),(3,15),(3,14),(3,13),(2,13),(2,12),(3,12),(4,12),(5,12),(5,13),(4,13),(4,14),(4,15),(5,15),(5,14),(6,14),(6,15),(7,15),(7,14),(7,13),(6,13),(6,12),(7,12),(7,11),(7,10),(6,10),(6,11),(5,11),(4,11),(4,10),(5,10),(5,9),(4,9),(4,8),(5,8),(6,8),(6,9),(7,9),(7,8),(8,8),(8,9),(9,9),(9,8),(10,8),(11,8),(11,9),(10,9),(10,10),(11,10),(11,11),(10,11),(9,11),(9,10),(8,10),(8,11),(8,12),(9,12),(9,13),(8,13),(8,14),(8,15),(9,15),(9,14),(10,14),(10,15),(11,15),(11,14),(11,13),(10,13),(10,12),(11,12),(12,12),(13,12),(13,13),(12,13),(12,14),(12,15),(13,15),(13,14),(14,14),(14,15),(15,15),(15,14),(15,13),(14,13),(14,12),(15,12),(15,11),(15,10),(14,10),(14,11),(13,11),(12,11),(12,10),(13,10),(13,9),(12,9),(12,8),(13,8),(14,8),(14,9),(15,9),(15,8),(15,7),(14,7),(14,6),(15,6),(15,5),(15,4),(14,4),(14,5),(13,5),(13,4),(12,4),(12,5),(12,6),(13,6),(13,7),(12,7),(11,7),(11,6),(10,6),(10,7),(9,7),(8,7),(8,6),(9,6),(9,5),(8,5),(8,4),(9,4),(10,4),(10,5),(11,5),(11,4),(11,3),(11,2),(10,2),(10,3),(9,3),(8,3),(8,2),(9,2),(9,1),(8,1),(8,0),(9,0),(10,0),(10,1),(11,1),(11,0),(12,0),(13,0),(13,1),(12,1),(12,2),(12,3),(13,3),(13,2),(14,2),(14,3),(15,3),(15,2),(15,1),(14,1),(14,0),(15,0)]

　ヒルベルト曲線にかぎりませんが、多くの空間充填曲線は上記のような離散的な曲線の
極限をとって構成されます。プログラムで扱う場合にはこの離散的な曲線のまま扱うほう
がなにかと都合がよいため、 2ⁿ の大きさの表を考えて、そのセルにヒルベルト曲線で
順序をつけたうえで二分探索木で処理するようにします。まずは 2ⁿ の数値のみを扱う
ように構成し、ほかの値はハッシュ関数で 2ⁿ のハッシュ値に mapping して扱います。

　さてこれにて二分探索木で (x, y) を扱うためには m = curve n (hash x) (hash y) を
求めればよいことがわかりました。しかしこのままでは探索時にも (x, y) の両方が必要
で、 x のみや y のみが与えられたときに探索する方法がわかりません。

　ふたたびさきほどの表に向きあうと

<img src="hilbert-x.svg">

<img src="hilbert-y.svg">

　ちょうど表の ½ の地点で縦横に分割するときれいに分かれます。
さらに都合のよいことにこの曲線を直線になおしたとき、
それぞれ ¼, ½, ¾ の位置になります。つまり x に基づいた探索では
直線の ½ の位置を基準にし、 y に基づいた探索では直線の ¼, ¾ の位置を
基準に探索すればよさそうです。さらにこれは再帰的に繰り返されます。
なお途中で x と y の向きが変わる場合がありますので、それをシアンとマゼンタで塗り分けました。

<img src="hilbert-z.svg">

　表の x または y が与えられたとき、直線の区間 [p, q] に x や y を通過する点が存在するかを
判定できればよさそうです。たとえば表の左上を (0, 0) 右下を (1, 1) とし、また直線も左上の端点が 0 右上の端点が 1 と
すれば、 x = ¼ ならば [½, ¾] の区間は探索しなくてもよいと即座に判定できます。
（※ ただし表も直線もそれぞれ座標がとりうる値は [0, 1)² および [0, 1) というふうに右端の端点を含まないことに注意）

　この直観をコードになおすと以下のようになります。

@vertical.hs
@horizontal.hs

@chapter
二分探索木に応用してみる

　さてこれで二分探索におけるいろいろなアルゴリズムやデータ構造が利用可能になりました。
平衡二分探索木にするなどはまた別途するとして、素朴な二分探索木が動作するかを確かめてみます。

@tree.hs

@section
動作確認

GHCi で動作確認をしてみます。
今回はわかりやすい例として square(x)=x² を考えます。 sqrt(x)=√x として square⁻¹=sqrt です。
たとえば square(4)=16 で sqrt(16)=4 です。

@code """
> :set +m
> let square :: Relation Int.Int8 Int.Int8
|     square = insert 4 16 (insert 3 9 (insert 0 0 (insert 1 1 (singleton 2 4))))
|
> print square
Branch [(2,4)] (27 % 32768) (Branch [(1,1)] (1 % 32768) (Branch [(0,0)] (0 % 1) Leaf Leaf) Leaf) (Branch [(3,9)] (35 % 32768) Leaf (Branch [(4,16)] (461 % 32768) Leaf Leaf))
> lookupX 0 square
[0]
> lookupX 1 square
[1]
> lookupX 2 square
[4]
> lookupX 3 square
[9]
> lookupX 4 square
[16]
> lookupY 0 square
[0]
> lookupY 1 square
[1]
> lookupY 4 square
[2]
> lookupY 9 square
[3]
> lookupY 16 square
[4]
"""
